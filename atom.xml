<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荏苒。</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.eyrefree.org/"/>
  <updated>2018-01-21T16:08:23.388Z</updated>
  <id>http://www.eyrefree.org/</id>
  
  <author>
    <name>EyreFree</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蜂鸟商家版 iOS 组件化 / 模块化实践总结</title>
    <link href="http://www.eyrefree.org/LPDBusiness/"/>
    <id>http://www.eyrefree.org/LPDBusiness/</id>
    <published>2018-01-20T07:00:00.000Z</published>
    <updated>2018-01-21T16:08:23.388Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4af3f3d9?w=750&amp;h=400&amp;f=png&amp;s=302366" alt=""></p><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零. 前言"></a>零. 前言</h2><blockquote><p>“蜂鸟配送商家版”是一款针对商家打造的专业配送软件，有了这款应用，您可以使用蜂鸟商家版呼叫所有平台订单及电话订单配送，餐饮、鲜花、蛋糕、生鲜、商超均可配送。超低运费，清晰合理。海量补贴，充值返现。</p></blockquote><p>以上这段对「蜂鸟商家版」的描述摘自 <a href="https://fengniao.ele.me/business.html" target="_blank" rel="noopener">蜂鸟配送官网</a>，大概可以理解为蜂鸟商家版是一个给广大商家用来发单呼叫配送员的 App。许多同学可能只听说过「饿了么」外卖应用，但是对支撑起外卖配送的后勤业务「蜂鸟配送」却知之甚少，实际上每天海量的外卖订单都是由蜂鸟配送系统进行处理和配送最终送到消费者手中的。外卖 O2O 是由外卖平台、商户、配送系统这三方合作共同完成的，缺一不可。O2O 最核心的价值就是人与服务的连接，而这种连接最终都是通过配送才得以实现的。</p><p>自 2016 年底开始我参与蜂鸟商家版的维护工作，除了日常的开发迭代以外，期间还参与推进了项目 Swift 化、项目组件化 / 模块化、非业务组件开源化等技术改造工作，今天这篇文章就给大家分享一下蜂鸟商家版 iOS 的组件化 / 模块化实践过程和自己的心得体会。</p><h2 id="一-背景分析"><a href="#一-背景分析" class="headerlink" title="一. 背景分析"></a>一. 背景分析</h2><p>蜂鸟商家版 iOS 端代码使用 Git 进行管理，代码托管在内网的 GitLab 上。项目的依赖管理工具是大家比较熟悉的 CocoaPods，除了 RN 模块为了和 Android 组公用采用 Submodule 进行管理外，其他所有的子模块都采用 Pods 库的方式引入。</p><h3 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h3><p>在「蜂鸟商家版 iOS 组件化 / 模块化」工作开展之前，项目主要存在如下这些问题：</p><ul><li>项目臃肿不堪</li></ul><p>在组件化 / 模块化之前，蜂鸟商家版 App 的所有代码 / 资源文件等都是在同一个主工程里的，只有 RN 仓库或组内公用私有库等极少部分代码游离于主工程之外，所以在开发时，每一次都要编译整个项目的所有代码，十分低效。这个问题在独立开发时还不是十分明显，毕竟虽然项目大但是代码只有一个人在提交，所以项目代码量增加也不是那么夸张而且对项目发生的变化比较熟悉。但是当多人协作开发时，这个缺陷就暴露了出来，大家在各自开发不同的业务时，不仅要时刻和他人同步项目变化、读懂他人代码，还要每次编译完整个项目才能对自己所做的一点修改进行调试，效率低下。</p><ul><li>团队规模变化</li></ul><p>我开始参与蜂鸟商家版 iOS 端的维护时，之前只有一个前辈在维护，也就是一个人独立维护一个 App。然后过了没多久，他离职去了另一家公司，所以又变成了一个人独立维护这个 App。这时候因为是独立开发，所以也不存在什么太大的问题。但随着团队扩大，后面陆续来了几位同事共同负责这个项目的维护工作，大家都在同一个工程上进行业务开发，经常遇到如代码冲突、开发效率低下、职责划分不清、代码管理混乱等问题。</p><ul><li>业务发展压力</li></ul><p>由于公司处在高速发展的阶段，业务增长很快，最直观的表现就是市场 &amp; 客服部门不断接到大量一线使用者的使用反馈或诉求，最后就变成了产品展示给我们开发人员的一份接一份的 PRD。紧凑的业务开发需求和各种灵活的功能迫使我们想尽一切能够使用的办法来提高开发效率，提高提测质量。</p><ul><li>代码管理混乱</li></ul><p>当我开始参与这个项目的维护时，这个项目就已经是一个 Swift 和 OC 混编的项目了，然后还有 RN 和 H5 代码，可以说是十分复杂了。虽然这不是我厂唯一一个 Swift 和 OC 的混编项目，但绝对是当时 Swift 化最高的一个项目，约 25% 的代码为 Swift。众所周知，Swift 和 OC 的互相调用远不如 Java 和 Kotlin 的互相调用那么顺滑（反正你现在知道了），并且处处藏着危机，暗坑无数，所以迫切需要找一个方式，将 Swift 和 OC 代码进行整理、转换或者分隔。毕竟，这个文件是 OC 下一个文件就是 Swift 这种频繁的思维转换在业务开发这种本就十分紧张的场景下，会使人十分疲惫，不利于开发工作的顺利进行。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4ad93d93?w=800&amp;h=683&amp;f=png&amp;s=230419" alt=""></p><h3 id="2-怎样去解决"><a href="#2-怎样去解决" class="headerlink" title="2. 怎样去解决"></a>2. 怎样去解决</h3><p>为了解决以上这些问题，我们曾经进行过如下一些探索：</p><ol><li>移除无用的第三方库和资源文件，减少打包时间：效果不明显；</li><li>整理并推动内部 Gitflow 工作流，提高协作效率：有一些效果，但由于项目过大，日常协作仍然吃力；</li><li>研究 Swift 编译时间优化方法，提高编译效率：发现增加编译时间的都是 Swift 的一些常用语法糖，如果不用的话，严重降低开发效率，遂放弃；</li><li>在不拆分主工程的情况下，推动项目整个 Swift 化：由于之前维护项目的前辈离职，导致目前的项目开发人员都对原代码不是十分熟悉，不敢妄加改动，加之业务迭代频繁，开发和测试资源都十分紧张，该工作工作推进十分缓慢。</li></ol><p>可以发现上述尝试的结果都不是十分理想，在与 iOS 组内大佬们进行一些沟通，听取大佬们的意见后，决定对原项目进行「组件化 / 模块化拆分」工作，它能带来如下这些好处：</p><ul><li>加快编译速度，不用再编译组件 / 模块外没有被依赖到的代码；</li><li>便于将每个模块指定给不同负责人进行管理；</li><li>降低合并难度，减小冲突和出错概率，提高业务开发效率；</li><li>将 Swift 和 OC 代码进行分离，便于进一步 Swift 化工作的推进；</li><li>可为模块编写单元测试，提高工作效率，同时方便测试人员进行有针对性的测试。</li></ul><h2 id="二-目标设定"><a href="#二-目标设定" class="headerlink" title="二. 目标设定"></a>二. 目标设定</h2><ul><li>功能组件独立：保证所有的底层功能组件从主工程抽出，独立与主工程之外，便于复用、业务模块的调用；</li><li>业务模块划分与拆解：将业务按对应用途进行划分和拆解，想办法切断各业务之间的强依赖；</li><li>所有组件 / 模块独立编译：所有功能组件和业务模块能够独立于主工程进行编译，有各自的 Demo 工程；</li><li>CocoaPods 发布：在内网 GitLab 进行发布，并且之后对每个模块用 GitFlow 工作流进行管理和后续发布工作。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4ae5935d?w=840&amp;h=351&amp;f=png&amp;s=110856" alt=""></p><h2 id="三-计划制定"><a href="#三-计划制定" class="headerlink" title="三. 计划制定"></a>三. 计划制定</h2><p>说到组件化 / 模块化，那么什么是组件化 / 模块化呢？组件化和模块化的区别又在哪里呢？</p><p>组件，就是我们对功能的封装，一个功能就是一个组件，数据库、网络、文件操作、社会化分享等等这些功能都是组件。我们之所以要搞出组件的概念，是为了能够让我们的上层业务模块能够随时依赖和调用这些基础功能。组件基本上可以分为基础功能组件、通用 UI 组件、基础业务组件等这几类。所以为了满足上述要求，组件必须具有较高的独立性、扩展性以及复用性。</p><p>模块，就是对一系列有内聚性的业务进行整理，将其与其它业务进行切割、拆分，从主工程或原所在位置抽离为一个相对独立的部分。仅仅针对业务而言，比如说我们可以把订单业务独立为为一个模块，可以把个人中心独立为一个模块，把用户登录独立为一个模块等，在 App 中的体现就是一个个独立的 Git 仓库。模块化的一个好处是用到时可以搭积木，比如可以多个工程间复用同一个或几个业务模块，比如腾讯的 QQ 和 TIM，除了 UI 界面外 TIM 显然复用了大量现有的原 QQ 工程的业务模块代码，当然，我们这里暂时并没有这个需求。</p><p>经过小组会议讨论，我们的想法是将共用组件独立出来，然后直接按业务对现有主工程进行拆分同时兼顾 Swift 与 OC 分离，大致划分如下表所示：</p><h3 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a>1. 组件</h3><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">库名</th><th style="text-align:left">主要内容</th></tr></thead><tbody><tr><td style="text-align:left">基础（OC）</td><td style="text-align:left">LPDBOCFoundationGarbage</td><td style="text-align:left">基础的 OC 组件，各种零散的、混乱的视图、组件、控件、常量、OC 宏定义等，全放在这里，供上层调用。和他的库名一样，其本质就大概就是个垃圾桶。</td></tr><tr><td style="text-align:left">基础（Swift）</td><td style="text-align:left">LPDBPublicModule</td><td style="text-align:left">基础的 Swift 组件，包含一些公用的 Swift 扩展，和模块间解耦的协议。</td></tr><tr><td style="text-align:left">网络（OC）</td><td style="text-align:left">LPDBNetwork</td><td style="text-align:left">网络组件，对 AFNetworking 的浅层封装，同时包含了和网络相关的业务功能。</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2. 模块"></a>2. 模块</h3><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:left">库名</th><th style="text-align:left">主要内容</th></tr></thead><tbody><tr><td style="text-align:left">历史（OC）</td><td style="text-align:left">LPDBHistoryModule</td><td style="text-align:left">历史订单模块，包含和历史订单相关的资源文件、UI、业务逻辑代码等。</td></tr><tr><td style="text-align:left">登录（OC）</td><td style="text-align:left">LPDBLoginModule</td><td style="text-align:left">用户登录模块，包含和登录、注册页面相关的资源文件、UI、业务逻辑代码等。</td></tr><tr><td style="text-align:left">用户中心（OC）</td><td style="text-align:left">LPDBUserCenterModule</td><td style="text-align:left">用户中心模块，包含和用户个人中心以及状态相关的资源文件、UI、业务逻辑代码等。</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><h3 id="3-关系"><a href="#3-关系" class="headerlink" title="3. 关系"></a>3. 关系</h3><p>按照上面的思路，理想化的模块 / 组件依赖关系图大概是这个样子的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4a9c953e?w=548&amp;h=272&amp;f=png&amp;s=22346" alt=""></p><p>因为蜂鸟商家版的团队开发人员之前均没有过任何项目的拆分经验，大家也都是摸着石头过河，走一步看一步。所以虽然以上的拆分思路总体是对的，先拆组件后拆业务，但由于各种各样的原因，一些问题就在接下来的工作实施过程中暴露了出来。</p><h2 id="四-工作实施"><a href="#四-工作实施" class="headerlink" title="四. 工作实施"></a>四. 工作实施</h2><p>我们小组主要还是以业务开发为主，所以组件化 / 模块化工作都是大家抽空闲时间来完成，并没有进行硬性的排期和设置 Deadline。按照之前制定的计划，我们进行了以下这些工作：</p><h3 id="1-功能组件独立"><a href="#1-功能组件独立" class="headerlink" title="1. 功能组件独立"></a>1. 功能组件独立</h3><h4 id="1-1-LPDBOCFoundationGarbage"><a href="#1-1-LPDBOCFoundationGarbage" class="headerlink" title="1.1 LPDBOCFoundationGarbage"></a>1.1 LPDBOCFoundationGarbage</h4><p>LPDBOCFoundationGarbage 是我们项目最先抽出的部分，这个库将和 LPDBPublicModule 一起，作为整个工程的最底层，再往下就是。这个库的定位和它的名字一样，就是一个垃圾桶，啥都往里放。其中大致包含以下一些东西：</p><ul><li>自定义的 View 和控件，例如：小红点控件、刷新控件、加载控件、Tips 视图等；</li><li>自定义的 Controller，例如：基础控制器 BaseViewController、WebView 基础控制器 BaseWebViewController、自定义的弹框 AlertController等；</li><li>和业务相关的对基本类型或系统控件的扩展：对 NSObject、UIButton、UIImageView、UILabel 等添加的扩展代码 category；</li><li>甚至版本控制模块 LPDBVersionManager 也放在了这里。</li></ul><p>因为我们在进行拆分任务的同时，还在同时维持着项目的开发工作，所以我们暂时没有精力做细致的拆分工作，只能先把这些零散的部分先放在一起进行管理。</p><h4 id="1-2-LPDBPublicModule"><a href="#1-2-LPDBPublicModule" class="headerlink" title="1.2 LPDBPublicModule"></a>1.2 LPDBPublicModule</h4><p>LPDBPublicModule 是基础的 Swift 组件，这个库主要包含：</p><ul><li>一些公用的 Swift 扩展，例如：对 CGFloat、Date、NSString 等系统类型的 extension；</li><li>用于模块间解耦的协议。</li></ul><p>因为工程内的 Swift 代码大多是我们新写的，所以相对旧的 OC 代码而言，整理地更好一些，所以这个仓库干净很多</p><h4 id="1-3-LPDBNetwork"><a href="#1-3-LPDBNetwork" class="headerlink" title="1.3 LPDBNetwork"></a>1.3 LPDBNetwork</h4><p>LPDBNetwork 网络组件是我们项目完成 OC 和 Swift 基础部分后最先抽出的部分，刚开始我们认为这部分仅仅是单纯的业务网络请求操作和对 AFNetworking 的浅层封装，不包含界面 UI 逻辑等。不过当我们拆解完成后，发现其中还包含了一堆奇怪的东西：</p><ul><li>对 AFNetworking 的封装和网络操作的一些定义，例如：LPDBHttpManager、LPDBRequestObject 和 LPDBModel 等；</li><li>UI 操作，例如：等待视图 LPDBLoadingView 和 网络请求失败的提示等。</li></ul><p>这一部分的话，因为都是比较古老的代码，所以当初的开发人员都已经不再继续维护了，所以在只能是我们自己进行拆分的情况下，为了防止大的变更导致发生问题，所以没有对这一块进行更细致的拆解工作。毕竟再烂代码也比不能工作的代码要好。</p><h4 id="1-4-LPDBUIKit"><a href="#1-4-LPDBUIKit" class="headerlink" title="1.4 LPDBUIKit"></a>1.4 LPDBUIKit</h4><p>Swift 的 UI 库，我们将工程中的一些 Swift 视图和控件收集到了这个项目中，主要包含以下这些内容：</p><ul><li>视图，例如：LPDBEmptyDataView、SlideScrollView 等；</li><li>控件，例如：SlideTabKit 等。</li></ul><p>因为 Swift 代码总量还不是很大，所以这个库的东西目前也不是很多，以后会逐渐丰富起来。</p><h3 id="2-业务模块拆分"><a href="#2-业务模块拆分" class="headerlink" title="2. 业务模块拆分"></a>2. 业务模块拆分</h3><p>完成了上面的组件库的独立工作后，业务模块的拆解就相对轻松一些了，目前我们主要完成了三个业务模块的拆分工作。</p><h4 id="2-1-LPDBHistoryModule"><a href="#2-1-LPDBHistoryModule" class="headerlink" title="2.1 LPDBHistoryModule"></a>2.1 LPDBHistoryModule</h4><p>LPDBHistoryModule 历史订单模块，和历史订单页面相关的信息都在该模块中，主要包含以下内容：</p><ul><li>UI，例如：历史订单界面、历史订单列表 Cell、加载视图等；</li><li>数据模型，例如：历史订单模型；</li><li>历史订单列表相关的网络请求。</li></ul><p>因为该模块相对来说比较独立，所以拆分过程也比较顺利，主要依赖了 LPDBPublicModule、LPDBNetwork、LPDBOCFoundationGarbage 组件。</p><h4 id="2-2-LPDBLoginModule"><a href="#2-2-LPDBLoginModule" class="headerlink" title="2.2 LPDBLoginModule"></a>2.2 LPDBLoginModule</h4><p>LPDBLoginModule 用户登录模块是一个与用户登录、注册以及用户登录信息有关的模块，主要包含了以下信息：</p><ul><li>UI，例如：用户登录界面、用户注册界面等；</li><li>数据模型，例如：用户信息模型、用户信息地址模型等；</li><li>登录与注册相关的网络请求。</li></ul><p>该模块相比较历史订单模块复杂了一些，不过仍然比较顺利，主要依赖了 LPDBPublicModule、LPDBOCFoundationGarbage、LPDBNetwork 组件。</p><h4 id="2-3-LPDBUserCenterModule"><a href="#2-3-LPDBUserCenterModule" class="headerlink" title="2.3 LPDBUserCenterModule"></a>2.3 LPDBUserCenterModule</h4><p>LPDBUserCenterModule 用户中心模块是一个与用户个人中心以及用户信息修改有关的模块，主要包含了以下信息：</p><ul><li>UI，例如：用户中心界面、用户电话修改界面、用户密码修改界面等；</li><li>数据模型，例如：用户详细信息模型、用户信息地址模型等；</li><li>用户中心相关的网络请求，例如：修改电话号码、请求验证码等。</li></ul><p>该模块主要依赖了 LPDBOCFoundationGarbage 组件和 LPDBLoginModule 模块。</p><h4 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h4><p>剩下的其他一些模块仍然处于计划中的状态，暂未进行拆分。到这一步的话，库间依赖关系大致如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4a8c0fca?w=1240&amp;h=608&amp;f=png&amp;s=111714" alt=""></p><p>可以看到其中存在一些不太合理的依赖关系，如 LPDBUserCenterModule 依赖 LPDBLoginModule 模块，也就是所谓的业务模块横向依赖问题，接下来，我们就要处理这一问题。</p><h3 id="3-解除耦合"><a href="#3-解除耦合" class="headerlink" title="3. 解除耦合"></a>3. 解除耦合</h3><p>由于之前开发过程中从未有过任何模块化的考量，所以蜂鸟商家版的代码非常杂糅，项目依赖关系十分复杂，主要可以分为以下三类耦合：</p><ul><li>界面耦合：App 执行过程中，硬编码的界面间的跳转行为；</li><li>工程耦合：某些模块在运行时需要依赖主工程的代码才能运行或实现完整的功能；</li><li>依赖耦合：两个业务模块之间的有依赖。</li></ul><h4 id="3-1-模块间组件共用"><a href="#3-1-模块间组件共用" class="headerlink" title="3.1 模块间组件共用"></a>3.1 模块间组件共用</h4><p>在拆分业务模块的过程中，经常发生两个业务模块同时引用某一块业务代码的问题，这时我们就需要对这一块代码进行理解，首先区分它到底应不应该划分到业务层来？</p><ul><li>如果是的话，应该划归到哪一个模块中去更合理一些；</li><li>如果不是的话，应该将这一部分代码下沉到哪一个组件库中去比较合适，或者独立为一个组件。</li></ul><p>在 LPDBUserCenterModule 的抽离过程中就遇到了这个问题，LPDBUserCenterModule<br> 和 LPDBLoginModule 共同依赖了几个和用户信息有关的数据模型，导致需要发生模块间横向依赖，所以我们将共用的数据模型抽出，然后下沉到了 LPDBOCFoundationGarbage 中。</p><h4 id="3-2-模块间耦合"><a href="#3-2-模块间耦合" class="headerlink" title="3.2 模块间耦合"></a>3.2 模块间耦合</h4><p>另一个经常遇到的问题就是跨模块调用代码的问题了，不仅是模块与模块间代码的互相调用、模块间页面的跳转，还有模块反向调用主工程代码等问题，这个问题的解决我们分了三步：</p><ul><li>反射调用</li></ul><p>因为工程的复杂性和以前代码的不规范，导致我们在处理切割业务模块时比较痛苦，所以我们在刚开始抽出模块时采用了一种快速但不太安全的方式进行解耦，比如在 LPDBUserCenterModule 模块中需要调用主工程的 getMiddlePageVC 方法时，我们用了如下临时解决方案：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication].delegate respondsToSelector:<span class="keyword">@selector</span>(getMiddlePageVC)]) &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *info = [[<span class="built_in">UIApplication</span> sharedApplication].delegate performSelector:<span class="keyword">@selector</span>(getMiddlePageVC)];</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主工程的 中实现这个接口：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// LPDBUserCenterModule</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)getMiddlePageVC;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)getMiddlePageVC &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这一方案的优点就是灵活，利用 NSClassFromString、performSelector 等方式，能够快速解决各种耦合问题，瞬间切割出模块。但缺点也显而易见，字符串硬编码，维护成本大，去掉了编译器检查，容易翻车。</p><ul><li>协议调用</li></ul><p>所以自然而言地，当我们的某个业务模块的拆分工作基本定型时，我们就开始将第一步中的反射调用方式替换为协议的方式进行调用，比如当 LPDBLoginModule 模块需要调用主工程的 getCoordinate 方法时，示例如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> delegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![delegate conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">AppDelegateProtocol</span>)]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CLLocationCoordinate2D</span> coordinate = [delegate coordinate];</span><br></pre></td></tr></table></figure><p>然后在主工程中实现该方法：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> LPDBLoginModule;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> (<span class="title">Protocol</span>)  &lt;<span class="title">AppDelegateProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span> (<span class="title">Protocol</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CLLocationCoordinate2D</span>)getCoordinate &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.coordinate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>但是，样的改变并不能彻底解决所编写的模块间互相调用的代码缺乏编译器检查的问题，而仅仅是对调用方做了判断加上了容错，并不能在编译期就让开发人员察觉到问题，一定要进行测试才可以，所以这种方式也不是十分理想。</p><ul><li>Lotusoot 解耦工具</li></ul><p>那么为了彻底解决问题，我们开发和引入了组件通信和工具 Lotusoot，调用方式有下列几种可供参考：</p><ul><li>服务调用</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lotus = s(<span class="type">AccountLotus</span>.<span class="keyword">self</span>) </span><br><span class="line"><span class="keyword">let</span> accountModule: <span class="type">AccountLotus</span> = <span class="type">LotusootCoordinator</span>.lotusoot(lotus: lotus) <span class="keyword">as</span>! <span class="type">AccountLotus</span></span><br><span class="line">accountModule.login(username: <span class="string">"admin"</span>, password: <span class="string">"wow"</span>) &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error ?? <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>短链注册</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error: <span class="type">NSError</span>? = <span class="type">LotusootRouter</span>.register(route: <span class="string">"newproj://account/login"</span>) &#123; (lotusootURL) <span class="keyword">in</span></span><br><span class="line">    accountModule.showLoginVC(username: <span class="string">"admin"</span>, password: <span class="string">"wow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>短链调用</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> param: <span class="type">Dictionary</span> = [<span class="string">"username"</span> : <span class="string">"admin"</span>,</span><br><span class="line">                                 <span class="string">"password"</span> : <span class="string">"wow"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无回调                                 </span></span><br><span class="line"><span class="type">LotusootRouter</span>.<span class="keyword">open</span>(route: <span class="string">"newproj://account/login"</span>, params: param)</span><br><span class="line"><span class="comment">// 有回调</span></span><br><span class="line"><span class="type">LotusootRouter</span>.<span class="keyword">open</span>(route: <span class="string">"newproj://account/login"</span>, params: param).completion &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error ?? <span class="string">"open success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⚠️不推荐的用法，用 ?pram0=xxx 这样的形式导致字符串散落在各处，不易管理。</span></span><br><span class="line"><span class="comment">// 但为了保证 Hybrid 项目中 H5 页面的正常跳转，提供了此种调用</span></span><br><span class="line"><span class="type">LotusootRouter</span>.<span class="keyword">open</span>(url: <span class="string">"newproj://account/login?username=zhoulingyu"</span>).completion &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(error ?? <span class="string">"open success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以参见 <a href="http://zhoulingyu.com/2017/11/29/iOS-modularized-tool-Lotusoot/" target="_blank" rel="noopener">iOS 灵活的 模块化/组件化 工具与规范 Lotusoot 解说</a> 一文，在此不多做赘述。类似的工具还有 <a href="https://github.com/alibaba/BeeHive" target="_blank" rel="noopener">BeeHive</a> 和 <a href="https://github.com/LPD-iOS/LPDMvvmRouterKit" target="_blank" rel="noopener">LPDMvvmRouterKit</a> 等，大家可以自行进一步探索。</p><p>最终结构就变成了如图所示的样子：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4aa60211?w=708&amp;h=408&amp;f=png&amp;s=44455" alt=""></p><h2 id="五-问题整理"><a href="#五-问题整理" class="headerlink" title="五. 问题整理"></a>五. 问题整理</h2><h3 id="1-不合理的分层结构和库间依赖"><a href="#1-不合理的分层结构和库间依赖" class="headerlink" title="1. 不合理的分层结构和库间依赖"></a>1. 不合理的分层结构和库间依赖</h3><p>由于参与拆分工作的人员比较缺乏组件化经验，所以导致某些库的拆分不是十分合理，某些应该沉入底层的公用 Model 和常量等没有在开始时就放到一个合理的位置。业务模块之间也存在一些不合理的横向依赖，没有进行一个合理的业务边界划分。这些原因导致我们在进行拆分工作时经常需要回过头来对已经拆出来的模块和组件重新进行整理和处理，重复劳动量很大。</p><h3 id="2-拆分粒度不适中"><a href="#2-拆分粒度不适中" class="headerlink" title="2. 拆分粒度不适中"></a>2. 拆分粒度不适中</h3><p>某些库比如 LPDBOCFoundationGarbage 比较庞大，而像 LPDBUIKit 这样的库中内容却非常少，这一点的处理上存在问题。如果一个拆分完成的库仍然比较臃肿的化，说明仍然存在细化拆分的必余地。</p><h3 id="3-工作进度难以控制"><a href="#3-工作进度难以控制" class="headerlink" title="3. 工作进度难以控制"></a>3. 工作进度难以控制</h3><p>由于没有能提前制定好详细的进度计划表，加上业务工作的挤压，导致我们花在组件化 / 模块化工作上的时间比较零散。本意是希望大家能够灵活安排工作，合理处置业务开发与技术改造工作之间的关系，但效果不是很理想，表现就是组件化 / 模块化工作的进行没有连续性，大家的积极性和工作效率也都不高。</p><h2 id="六-经验总结"><a href="#六-经验总结" class="headerlink" title="六. 经验总结"></a>六. 经验总结</h2><h3 id="1-工作开始前要进行技术调研"><a href="#1-工作开始前要进行技术调研" class="headerlink" title="1. 工作开始前要进行技术调研"></a>1. 工作开始前要进行技术调研</h3><p>查看和学习一些同类成功的案例资料或者向业内大佬们请教能够对计划的制定带来便利，能够使我们避免很多错误的设计，少走一些弯路，降低返工率。</p><h3 id="2-制定详细整体规划"><a href="#2-制定详细整体规划" class="headerlink" title="2. 制定详细整体规划"></a>2. 制定详细整体规划</h3><blockquote><p>在准备作战时，我常常发现定好的计划没有用处，但计划的过程仍必不可少。—— 德怀特·艾森豪威尔</p></blockquote><p>制定详细的整体规划能够在设计阶段就将一些不合理的地方暴露出来，从而拿出解决方案使问题提前得到解决，或者把不合理的内容删减替换掉，例如分层不合理、库间依赖这样的问题，就会减少很多。拿出细致的任务拆分计划和工作量预估，也能更合理地将任务安排到开发人员手中，在提升工作效率的同时也能尽量避免和业务开发产生冲突。</p><h3 id="3-注意对代码质量的控制"><a href="#3-注意对代码质量的控制" class="headerlink" title="3. 注意对代码质量的控制"></a>3. 注意对代码质量的控制</h3><p>好的代码和编码习惯能够大幅提升项目的可维护性，为之后的工作带来便利。我们之前旧的 OC 代码比较混乱，基本处于无法维护的状态，拆分起来十分痛苦；而新写的 Swift 代码明显质量要高很多（这真的不是我们自夸…），拆分起来就顺利多了。</p><h3 id="4-重视信息的文档化"><a href="#4-重视信息的文档化" class="headerlink" title="4. 重视信息的文档化"></a>4. 重视信息的文档化</h3><p>每一个拆分出的模块及时添加文档，嫌麻烦的话至少要建立一份通用的 README 模板，每一个模块或组件的建立者把模块内容、拆分目的、设计思路等基本信息记录一下，有什么坑或者注意点也可以文档化，是以后的长期项目维护成为可能。</p><h2 id="七-开源成果"><a href="#七-开源成果" class="headerlink" title="七. 开源成果"></a>七. 开源成果</h2><p>我们在组件化 / 模块化工作期间，产出的一些库和工具放在了 GitHub 上进行开源，给大家一些借鉴的同时，也希望能够收到大家的意见和建议，提高我们项目本身的质量：</p><table><thead><tr><th style="text-align:left">库名</th><th style="text-align:left">简介</th><th style="text-align:left">仓库地址</th></tr></thead><tbody><tr><td style="text-align:left">Lotusoot</td><td style="text-align:left">灵活的 Swift 组件解耦和通信工具</td><td style="text-align:left"><a href="https://github.com/Vegetarians/Lotusoot" target="_blank" rel="noopener">https://github.com/Vegetarians/Lotusoot</a></td></tr><tr><td style="text-align:left">Bamboots</td><td style="text-align:left">一个面向协议的 Swift 网络库</td><td style="text-align:left"><a href="https://github.com/mmoaay/Bamboots" target="_blank" rel="noopener">https://github.com/mmoaay/Bamboots</a></td></tr><tr><td style="text-align:left">bigkeeper</td><td style="text-align:left">一个 iOS &amp; Android 模块化项目效率提升工具</td><td style="text-align:left"><a href="https://github.com/BigKeeper/bigkeeper" target="_blank" rel="noopener">https://github.com/BigKeeper/bigkeeper</a></td></tr><tr><td style="text-align:left">SideNavigation</td><td style="text-align:left">一个支持侧滑且可自定义的侧边栏</td><td style="text-align:left"><a href="https://github.com/CNKCQ/SideNavigation" target="_blank" rel="noopener">https://github.com/CNKCQ/SideNavigation</a></td></tr><tr><td style="text-align:left">ViewPagers</td><td style="text-align:left">一个支持手势的 Segmented Control</td><td style="text-align:left"><a href="https://github.com/CNKCQ/ViewPagers" target="_blank" rel="noopener">https://github.com/CNKCQ/ViewPagers</a></td></tr><tr><td style="text-align:left">EFAutoScrollLabel</td><td style="text-align:left">一个带跑马灯效果的 UILabel</td><td style="text-align:left"><a href="https://github.com/EyreFree/EFAutoScrollLabel" target="_blank" rel="noopener">https://github.com/EyreFree/EFAutoScrollLabel</a></td></tr></tbody></table><h2 id="八-后记"><a href="#八-后记" class="headerlink" title="八. 后记"></a>八. 后记</h2><p>本文基本描述了蜂鸟商家版 App 到目前为止的组件化 / 模块化实践情况，希望本文能够给您的移动项目演进提供一些借鉴。在此过程中我们产出的一些文章、开源库和工具，也希望能给大家带来一定的帮助或者启发。欢迎大家提出各种反馈和建议或，帮助我们继续改进和提高。</p><p>2017 年底，也就是差不多我参与蜂鸟商家版的维护工作满一年的样子，由于业务调整的原因这个 App 已经移交给别的团队进行维护了，导致项目的 Swift 化和组件化 / 模块化工作并没有全部完成，这一点有些遗憾。不过还是希望蜂鸟商家版能够越来越好，继续为广大商家朋友们服务。</p><p>好消息是，接下来我主要参与蜂鸟团队版 App 的架构工作，这一次我们根据之前暴露出的问题制定了详细的工作计划，有了蜂鸟商家版的踩坑经验后，我相信这一次我们一定能顺利完成目标。2018，加油，一起拼！</p><p>本文编写过程中参考了以下文章，在此对原作者们表示感谢：</p><ol><li><a href="https://36kr.com/p/5100487.html" target="_blank" rel="noopener">即时配送网之于外卖O2O，配送的更高境界是社群经营</a></li><li><a href="https://www.jianshu.com/p/79e4df63f31f" target="_blank" rel="noopener">谈谈我的理解-组件化/模块化</a></li><li><a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a></li><li><a href="http://lincode.github.io/Modularity" target="_blank" rel="noopener">豆瓣App的模块化实践</a></li><li><a href="http://www.infoq.com/cn/articles/the-road-of-mobile-tmall-decoupling" target="_blank" rel="noopener">手机天猫解耦之路</a></li><li><a href="http://www.infoq.com/cn/articles/jd-ios-component-management" target="_blank" rel="noopener">京东iOS客户端组件管理实践</a></li></ol><hr><blockquote><p>如有任何知识产权、版权问题或理论错误，还请指正。<br><a href="https://juejin.im/post/5a620cf5f265da3e36415764" target="_blank" rel="noopener">https://juejin.im/post/5a620cf5f265da3e36415764</a><br>转载请注明原作者及以上信息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4af3f3d9?w=750&amp;amp;h=400&amp;amp;f=png&amp;amp;s=302366&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;零-前言&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://www.eyrefree.org/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Git 踩坑：Git Push 远端无分支不提示</title>
    <link href="http://www.eyrefree.org/GitPush/"/>
    <id>http://www.eyrefree.org/GitPush/</id>
    <published>2017-12-25T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.988Z</updated>
    
    <content type="html"><![CDATA[<p>上周遇到一个 Git 配置导致的问题，踩坑过程如下。</p><h2 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h2><ol><li>首先找一个远端 Git 仓库，clone 到本地；</li><li>在本地新建一个分支 test（名字随意，只要远端不存在这个分支即可）并切换到该分支；</li><li>执行 <code>git push</code> 命令后会发现终端显示了 <code>Everything up-to-date</code>，会让人误以为该分支成功推到了远端；</li><li>实际上问题已经出现了，这里 <code>git push</code> 指令并没有正确提示我们远端不存在该分支。我们可以检查一下远端 Git 仓库，的确没有把 test 分支推上去；</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3e087cf1?w=585&amp;h=366&amp;f=png&amp;s=55199" alt=""></p><ol><li>这个问题有多坑呢？假设没察觉这里回显不对，而是把本地分支删了干别的去了，估计就哭了。</li></ol><h2 id="二-问题解决"><a href="#二-问题解决" class="headerlink" title="二. 问题解决"></a>二. 问题解决</h2><ol><li>查了 N 多资料；</li><li>对比了 N 多类似案例；</li><li>耗费了无数脑细胞；</li><li>终于在 <a href="http://timothyqiu.com/" target="_blank" rel="noopener">TimothyQiu</a> 大大告诉我解决方法之后解决了该问题，😂；</li><li>问题原因大概是因为 <code>gitconfig</code> 中的 参数设置异常导致的，我们可以执行 <code>git config -l</code>  命令查看当前的 Git 配置，可以看到 <code>push.default</code> 的值为 <code>matching</code>：</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c4f77f6?w=805&amp;h=381&amp;f=png&amp;s=63849" alt=""></p><ol><li>用 <code>git config --global push.default simple</code> 命令把它改成 <code>simple</code> 即可：</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c565841?w=804&amp;h=396&amp;f=png&amp;s=69369" alt=""></p><ol><li>然后执行 <code>git push</code> 命令就可以正常获取错误提示信息啦：</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c6b61bd?w=518&amp;h=103&amp;f=png&amp;s=11300" alt=""></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/12/25/2017-12-25-Git-Push/">http://www.eyrefree.org/2017/12/25/2017-12-25-Git-Push/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周遇到一个 Git 配置导致的问题，踩坑过程如下。&lt;/p&gt;
&lt;h2 id=&quot;一-问题描述&quot;&gt;&lt;a href=&quot;#一-问题描述&quot; class=&quot;headerlink&quot; title=&quot;一. 问题描述&quot;&gt;&lt;/a&gt;一. 问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先找一个远端 Git 
      
    
    </summary>
    
      <category term="Git" scheme="http://www.eyrefree.org/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.eyrefree.org/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>利用 CodeBeat 为你在 GitHub 上的项目进行代码质量管理</title>
    <link href="http://www.eyrefree.org/CodeBeat/"/>
    <id>http://www.eyrefree.org/CodeBeat/</id>
    <published>2017-12-13T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.987Z</updated>
    
    <content type="html"><![CDATA[<p>CodeBeat 是一个免费为开源项目进行代码质量管理的工具（付费可以支持私有项目），目前已经支持的编程语言有 Swift、Objective-C、Go、Ruby、Python、Java、Kotlin、Javascript、Typescript、Elixir，无需对原有项目进行任何修改即可获取针对项目的完整质量分析，方便快捷。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们在 GitHub 上的代码仓库发生变更后，会通知 CodeBeat 执行分析操作刷新项目代码质量评分，并在完成后刷新项目评级 / 评分的状态或结果，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b248e6fda?w=1184&amp;h=673&amp;f=png&amp;s=98888" alt="代码质量效果预览"></p><p>CodeBeat 的同类产品有 Code Climate，目前支持 Ruby、Python、PHP、JavaScript、Java、TypeScript，不过官网显示<br> Swift、Go、Objective-C 的支持在计划中，因为我是 iOS 开发，所以暂时用不了这个，在一个 <a href="https://github.com/BigKeeper/bigstash" target="_blank" rel="noopener">Ruby 项目</a>有试过这个，看起来还好，有兴趣的同学也可以一试。</p><p>本文以 <a href="https://github.com/EyreFree/EFQRCode" target="_blank" rel="noopener">EFQRCode</a>(一个使用 Swift 作为开发语言的二维码库) 为例，简述怎样为自己的开源项目添加代码质量管理功能。</p><h2 id="1-注册-CodeBeat-账号"><a href="#1-注册-CodeBeat-账号" class="headerlink" title="1. 注册 CodeBeat 账号"></a>1. 注册 CodeBeat 账号</h2><p>打开 <a href="https://codebeat.co/" target="_blank" rel="noopener">https://codebeat.co/</a> 注册一个 CodeBeat 账号，也可以通过 GitHub 账户直接登陆。CodeBeat 服务对开源项目是免费的，所以你的私有项目无法享受到免费的持续构建服务。唔，当然，每月支付 20 美刀成为付费用户后可以解锁无限数量私有库的功能。</p><h2 id="2-从-GitHub-添加项目"><a href="#2-从-GitHub-添加项目" class="headerlink" title="2. 从 GitHub 添加项目"></a>2. 从 GitHub 添加项目</h2><p>登陆完成后，点击右边的 <code>Add Repository</code> 按钮即可开始添加自己的 Git 仓库，支持各种 Git 托管平台，甚至自建的也可以：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b27e29b81?w=1168&amp;h=411&amp;f=png&amp;s=35896" alt="Add Repository"></p><h2 id="3-开启代码质量管理"><a href="#3-开启代码质量管理" class="headerlink" title="3. 开启代码质量管理"></a>3. 开启代码质量管理</h2><p>第一次项目导入后会立即进行一次分析，试了一下速度还是比较快的（反正比持续集成快多了），反正我的项目导入以后刷新一下页面就出结果了。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b27f26013?w=1145&amp;h=493&amp;f=png&amp;s=54810" alt=""></p><p>唔，细心的同学可能会发现，这一步操作完成后我们在 GitHub 项目 Setting 中的 <code>Webhooks</code> 已经添加了一个属于 <code>codebeat.co</code> 的 Webhook，没错，以后项目代码发生更改后就会自动触发代码质量分析，不需要我们手动操作了。感兴趣的同学可以点击 <code>Edit</code> 按钮查看一下 CodeBeat 具体干了啥：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b294a4d04?w=916&amp;h=360&amp;f=png&amp;s=77638" alt="Webhooks"></p><p>关于 Webhook 感兴趣的同学可以查看 GitHub 官方的资料：<a href="https://developer.github.com/webhooks/" target="_blank" rel="noopener">https://developer.github.com/webhooks/</a>。</p><h2 id="4-查看代码质量分析结果"><a href="#4-查看代码质量分析结果" class="headerlink" title="4. 查看代码质量分析结果"></a>4. 查看代码质量分析结果</h2><p>点击进入该项目的分析结果，可以查看到具体的问题，如代码复杂性、代码风格、代码重复等，点击 <code>Quick Wins</code> 这一栏可以查看优先推荐修复的项目，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b2da5c683?w=1162&amp;h=401&amp;f=png&amp;s=70133" alt=""></p><p>我们可以对应分析出的代码质量问题对我们的工程代码进行修改，改完直接提交到仓库即可，Webhook 会通知 CodeBeat 进行刷新。</p><h2 id="没了"><a href="#没了" class="headerlink" title="没了"></a>没了</h2><p>在  的项目设置中可以看到更多有意思的玩法，比如将代码质量变化通知发送到 Slack 或邮箱等，也可以将代码质量评级徽标添加到自己的项目 README 中，大佬们可以自行研究…</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b2d2ad569?w=1148&amp;h=340&amp;f=png&amp;s=35402" alt="Setting"></p><p>祝操作顺利，🌈</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/12/13/2017-12-13-CodeBeat-GitHub/">http://www.eyrefree.org/2017/12/13/2017-12-13-CodeBeat-GitHub/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CodeBeat 是一个免费为开源项目进行代码质量管理的工具（付费可以支持私有项目），目前已经支持的编程语言有 Swift、Objective-C、Go、Ruby、Python、Java、Kotlin、Javascript、Typescript、Elixir，无需对原有项目
      
    
    </summary>
    
      <category term="GitHub" scheme="http://www.eyrefree.org/categories/GitHub/"/>
    
    
      <category term="CodeBeat" scheme="http://www.eyrefree.org/tags/CodeBeat/"/>
    
  </entry>
  
  <entry>
    <title>AppStore 审核 macOS 应用踩坑记录</title>
    <link href="http://www.eyrefree.org/MacAppStore/"/>
    <id>http://www.eyrefree.org/MacAppStore/</id>
    <published>2017-12-12T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Guideline-2-3-8-Performance"><a href="#1-Guideline-2-3-8-Performance" class="headerlink" title="1. Guideline 2.3.8 - Performance"></a>1. Guideline 2.3.8 - Performance</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guideline 2.3.8 - Performance</span><br><span class="line"></span><br><span class="line">We noticed that your app name to be displayed on the App Store does not sufficiently match the name of the app displayed when installed on macOS.</span><br><span class="line"></span><br><span class="line">iTunes Connect Name: EFQRCode</span><br><span class="line"></span><br><span class="line">App Name when Installed: EFQRCode.macos</span><br><span class="line"></span><br><span class="line">App Name when Launched: EFQRCode</span><br><span class="line"></span><br><span class="line">App Name in About/Quit Menu: macOS Example</span><br></pre></td></tr></table></figure><p>大概是说 AppStore 的应用名称和 App 安装后以及 App 内的菜单项目上显示的不符，需要修改每一处到一样后重新打包提交。</p><p>iTunes Connect Name：编辑 iTunes Connect 的 App 信息中 App 名称可更改；<br>App Name when Installed：编辑 Build Setting 中的 Product Name 可更改；</p><h2 id="2-Guideline-5-2-5-Legal"><a href="#2-Guideline-5-2-5-Legal" class="headerlink" title="2. Guideline 5.2.5 - Legal"></a>2. Guideline 5.2.5 - Legal</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guideline 5.2.5 - Legal</span><br><span class="line"></span><br><span class="line">Your app uses ‘macOS’ in the Installed App Name and Menu Item Names in a manner that is not consistent with Apple&apos;s trademark guidelines.</span><br><span class="line"></span><br><span class="line">Indicating Mac compatibility in the app name is not necessary for the Mac App Store.</span><br></pre></td></tr></table></figure><p>这条意思是 App 中不应该出现 ‘macOS’ 等不符合苹果商标指南的字样，全局搜索，把不合法的文字出现从按钮 / 菜单 / 页面去除即可。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/12/12/2017-12-12-AppStore-macOS/">http://www.eyrefree.org/2017/12/12/2017-12-12-AppStore-macOS/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Guideline-2-3-8-Performance&quot;&gt;&lt;a href=&quot;#1-Guideline-2-3-8-Performance&quot; class=&quot;headerlink&quot; title=&quot;1. Guideline 2.3.8 - Performance&quot;&gt;
      
    
    </summary>
    
      <category term="AppStore" scheme="http://www.eyrefree.org/categories/AppStore/"/>
    
    
      <category term="macOS" scheme="http://www.eyrefree.org/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>如何将 CocoaPods 库升级到 Swift 4</title>
    <link href="http://www.eyrefree.org/PodsSwift4/"/>
    <id>http://www.eyrefree.org/PodsSwift4/</id>
    <published>2017-12-05T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零. 前言"></a>零. 前言</h2><p>Swift 版本升级嘛，大家应该都很熟练了，菜单 -&gt; Edit -&gt; Convert -&gt; To Current Swift Syntax…，然后巴拉巴拉一顿操作。emmmn，抱歉，编译过了也不一定能正常使用。</p><p>这次 Swift 3 到 Swift 4 的更新和之前的大版本更新相比，已经平滑了很多，相较之前的动辄几百上千个 error，现在用 Xcode 进行 Convert 之后基本上只需要进行少量人工修正即可，不过仍然有一些点需要注意，本文将会对一些常见的坑或者注意点以及解决方法进行讨论。</p><p>本文以 <a href="https://github.com/EyreFree/EFCountingLabel" target="_blank" rel="noopener">EFCountingLabel</a> 的 1.0.3 版本和 Xcode 9.0 为例，主要关于原有的 Swift 3 的 CocoaPods 库到 Swift 4 的升级，仍处于 Swift 2 阶段的同学可暂时忽略本文。</p><h2 id="一-升级流程"><a href="#一-升级流程" class="headerlink" title="一. 升级流程"></a>一. 升级流程</h2><h3 id="1-查看当前版本"><a href="#1-查看当前版本" class="headerlink" title="1. 查看当前版本"></a>1. 查看当前版本</h3><p>首先用 Xcode 打开工程，看一下当前工程设置的 Swift 版本，如果过低的话可能无法直接 Convert，选中需要转换的 target 搜索 <code>swift_ver</code> 即可，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-51f2abcb6ffc474c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里 EFCountingLabel 的 Swift 版本为 3.2，如果是 2.x 的话需要自己想办法先转换成 Swift 3.x…</p><h3 id="2-Xcode-代码转换"><a href="#2-Xcode-代码转换" class="headerlink" title="2. Xcode 代码转换"></a>2. Xcode 代码转换</h3><p>接下来，就是利用 Xcode 实现代码转换了，菜单 -&gt; Edit -&gt; Convert -&gt; To Current Swift Syntax…，然后选中需要转换的 target，点击 <code>Next</code> 按钮即可：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7235c3b6ddb5f4fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-选择转换模式"><a href="#3-选择转换模式" class="headerlink" title="3. 选择转换模式"></a>3. 选择转换模式</h3><p>然后会出现一个转换模式选项，有 <code>Minimize Inference（recommended）</code> 和 <code>Match Swift 3 Behavior</code> 两个选择，苹果推荐的是第一个选项：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d603752b86a67dd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>苹果官方文档对这两个选项的描述如下，大意是：如果选第一个选项，会仅在必要的时候为方法或属性添加 <code>@objc</code> 标志，不过大部分工作需要用户（也就是你）手动完成，好处是能减少最终生成的二进制文件的大小；如果选择第二个选项，则会按 Swift 3 的方式给所有的地方直接添加 <code>@objc</code> 标志（关于 <code>@objc</code> 标志的介绍大家可以参考 Swift 翻译组的<a href="http://swift.gg/2016/04/20/swift-qa-2016-04-20/" target="_blank" rel="noopener">这篇文章</a>），缺点就是不会对生成的二进制文件大小进行优化（也就是跟 Swift 3 一样）：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-0565c3371c173e78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里我们分几种情况：</p><ol><li>如果你的 Swift 库不打算支持 OC 调用的话，选 <code>Minimize Inference（recommended）</code>，检查并且保存自动转换结果即可，然后可以直接跳到下一小节，请忽略下面这一大段；</li><li>如果你的 Swift 库打算支持 OC 调用，但是开发时间紧迫暂时没时间仔细设置 <code>@objc</code> 标志或者对这一点二进制文件体积的缩减并不是十分在意的话，选 <code>Match Swift 3 Behavior</code>，检查并且保存自动转换结果即可，然后可以直接跳到下一小节，请忽略下面这一大段；</li><li>如果你的 Swift 库打算支持 OC 调用，并且打算用推荐的方式进行优化的话，选 <code>Minimize Inference（recommended）</code>，保存更改，然后按下面的操作去做：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 编译工程；</span><br><span class="line">2. 修正那些提示你需要添加 @objc 标志的警告（请务必修正，不然即使编译能过运行时也可能会出问题）；</span><br><span class="line">3. 修正 Xcode 提示的不需要添加 @objc 标志的代码，持续构建和测试你的代码，直到没有任何警告出现；</span><br><span class="line">4. 打开工程设置；</span><br><span class="line">5. 选中 target，搜索 `@objc` 找到 `Swift 3 @objc Inference` 选项，设为 `Default`。</span><br></pre></td></tr></table></figure><p>唔，以上这段大概是原文翻译过来的了，官方文档原文如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-57b6b30c33b54e1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>需要注意的是，因为我们这里针对的并不是完整的 iOS 项目，而是 CocoaPods 库，如果你的 OC Demo 没有调用库中需要暴露的功能（或者干脆没有 OC Demo），辣么编译器可能完全不会给你任何提示而是直接通过编译了，直到你某一天在一个 OC 工程中引入这个库才会发现并不能调用到某些方法或获取某些属性。</p><p>所以其实麻烦之处在于，编译器并不会给你任何提示，因为编译器也不知道哪些类 / 属性 / 方法需要暴露，哪些需要被优化掉，需要开发人员自己决定并手动添加对应的 <code>@objc</code> 标志，总结起来的话有以下几点：</p><ol><li>需要在 OC 中调用一个 Swift 4 的类，需要让这个类继承 NSObject 并且在这个类前加上 @objc 标志；</li><li>需要在 OC 中调用一个 Swift 4 类的方法，需要在方法前加上 @objc 标志（这里有一个坑，如果是普通的函数调用还好，至少编译器会报错，如果是用 <code>#selector</code> 的方式调用的话，能过编译并且在运行时直接找不到对应方法而闪退，建议升完 Swift 4 检查一下所有的 #selector 调用）；</li><li>需要在 OC 中访问一个 Swift 4 类的某个属性，需要在属性前加上 @objc 标志（同上，如果是普通属性访问的话编译器会报错，但是 KVC 的话会在运行时找不到属性而崩溃，记得检查…）；</li><li>需要在 OC 中访问一个 Swift 4 类的扩展，只要在扩展前加上 @objc 标志，该扩展的属性和方法就都能被调用了。</li></ol><h3 id="4-更新-Xcode-设置"><a href="#4-更新-Xcode-设置" class="headerlink" title="4. 更新 Xcode 设置"></a>4. 更新 Xcode 设置</h3><ol><li>如下图所示，根据 Xcode 提示将工程设置进行更新，点击 Warning 后单击 <code>Perform Changes</code> 按钮即可；</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1018190-450ad5a3dfe1641f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol><li>检查设置，将所有 target 的 <code>Swift 3 @objc Inference</code> 设置（如果有的话）改为 <code>Default</code>，之前改过的话就不用改了；</li><li>搜索 <code>swift_ver</code>，可以看到当前的 <code>Swift Language Version</code> 已经是 <code>Swift 4</code> 了。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d10ebceafdcfcb6a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>剩下少量方法名变动之类的更新大家可以根据提示自行修改，到这里基本就完成了升级过程，不过先别急，接下来我们看注意事项。</p><h2 id="二-注意事项"><a href="#二-注意事项" class="headerlink" title="二. 注意事项"></a>二. 注意事项</h2><p>以下情况必须要给对应的属性或方法添加 <code>@objc</code> 标志（当然，他们所在的类肯定也需要添加 <code>@objc</code> 标志），不管是通过 OC 还是 Swift 调用：</p><ol><li>使用 <code>@selector()</code> 或 <code>#selector()</code> 方式调用的函数；</li><li>使用 KVC 进行访问的属性；</li><li>使用 IBOutlet 或者 IBAction 和 StoryBoard 绑定的函数或属性。</li></ol><p>这些有部分在官方文档中也有提及：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-940d3152de88724d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三-一些问题"><a href="#三-一些问题" class="headerlink" title="三. 一些问题"></a>三. 一些问题</h2><ol><li>同一工程的 Pods 库是否可以既有 Swift 3 的也有 Swift 4 的？</li></ol><p>Swift 的版本控制粒度在 framework 层面，也就是说同一个工程中不同的 framework 可以是按不同版本的 Swift 进行编译的，所以并不需要等待项目依赖的所有 Pods 库都支持 Swift 4 后再更新，完全可以将已经升级 Swift 4 的库先用起来。</p><ol><li><code>Swift 3 @objc Inference</code> 选项是干啥的？</li></ol><p>在 Swift 4 之前，编译器对 Objective-C 自动提供了一些 Swift 声明。例如，编译器会为 NSObject 子类的所有方法创建 Objective-C 入口点，该机制称为 @objc 推断（@objc Inference）。</p><p>在 Swift 4 中，这种自动的 @objc 推断已被废弃，因为生成所有这些 Objective-C 入口点有代价，会增大最终的二进制文件体积。当 <code>Swift 3 @objc Inference</code> 设置为 <code>On</code> 时，它会按照 Swift 4 之前的模式运行，不进行优化，也就是隐式为我们编写的所有 Swift 代码提供 OC 入口。</p><p>但是，当设置为 <code>On</code> 时 Xcode 会报一个警告，建议修复这个警告，并将设置切换到 <code>Default</code>。新的 Swift 项目的默认为“Default”。可以理解为该项设置为 <code>On</code> 时和上文代码转换时选择 <code>Match Swift 3 Behavior</code> 选项效果类似。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f32398e06f3f1538.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="四-没了"><a href="#四-没了" class="headerlink" title="四. 没了"></a>四. 没了</h2><p>升级完请务必跑一遍整体测试流程，暗坑无数，以防万一，祝大家线上稳定。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/12/05/2017-12-05-CocoaPods-Swift4/">http://www.eyrefree.org/2017/12/05/2017-12-05-CocoaPods-Swift4/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;零-前言&quot;&gt;&lt;a href=&quot;#零-前言&quot; class=&quot;headerlink&quot; title=&quot;零. 前言&quot;&gt;&lt;/a&gt;零. 前言&lt;/h2&gt;&lt;p&gt;Swift 版本升级嘛，大家应该都很熟练了，菜单 -&amp;gt; Edit -&amp;gt; Convert -&amp;gt; To C
      
    
    </summary>
    
      <category term="Swift" scheme="http://www.eyrefree.org/categories/Swift/"/>
    
    
      <category term="CocoaPods" scheme="http://www.eyrefree.org/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>EFColorPicker - 一个纯 Swift 的轻量级 iOS 颜色选择器</title>
    <link href="http://www.eyrefree.org/EFColorPicker/"/>
    <id>http://www.eyrefree.org/EFColorPicker/</id>
    <published>2017-10-09T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.987Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1018190-54ace766144a585f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFColorPicker 是一个纯 Swift 的轻量级 iOS 颜色选择器，受 <a href="https://github.com/sgl0v/MSColorPicker" target="_blank" rel="noopener">MSColorPicker</a> 启发。</p><blockquote><p><a href="https://github.com/EyreFree/EFColorPicker/blob/master/README.md" target="_blank" rel="noopener">English Introduction</a></p></blockquote><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/EyreFree/EFColorPicker" target="_blank" rel="noopener">https://github.com/EyreFree/EFColorPicker</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iOS 颜色选择器组件，它能够让用户选择自定义颜色，关键特性如下：</p><ul><li>支持 iPhone 和 iPad</li><li>自适应的用户界面</li><li>支持 RGB 和 HSB 两种颜色模式</li><li>比较完善的文档和注释</li><li>支持 iOS 8.0 (iPhone &amp; iPad) 及更高版本</li></ul><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table><thead><tr><th style="text-align:center">iPhone</th><th style="text-align:center">iPad   </th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-bde6c476505cd154.gif?imageMogr2/auto-orient/strip" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-c0bcbd2dd0bc027d.gif?imageMogr2/auto-orient/strip" alt="">   </td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>利用 <code>git clone</code> 命令下载本仓库；</li><li>利用 cd 命令切换到 Example 目录下，执行 <code>pod install</code> 命令；</li><li>随后打开 <code>EFColorPicker.xcworkspace</code> 编译即可。</li></ol><p>或执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:EyreFree/EFColorPicker.git; <span class="built_in">cd</span> EFColorPicker/Example; pod install; open EFColorPicker.xcworkspace</span><br></pre></td></tr></table></figure><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>iOS 8.0+</li><li>Xcode 9.0+</li><li>Swift 4.0+</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>EFColorPicker 可以通过 <a href="http://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a> 进行获取。只需要在你的 Podfile 中添加如下代码就能实现引入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &quot;EFColorPicker&quot;</span><br></pre></td></tr></table></figure><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>EyreFree, eyrefree@eyrefree.org</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/1018190-133df270d79d2d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFQRCode 基于 MIT 协议进行分发和使用，更多信息参见协议文件。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/10/09/2017-10-09-EFColorPicker/">http://www.eyrefree.org/2017/10/09/2017-10-09-EFColorPicker/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1018190-54ace766144a585f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="Swift" scheme="http://www.eyrefree.org/categories/Swift/"/>
    
    
      <category term="EFColorPicker" scheme="http://www.eyrefree.org/tags/EFColorPicker/"/>
    
  </entry>
  
  <entry>
    <title>EFResume - 一个普通的 Swift 简历模板</title>
    <link href="http://www.eyrefree.org/EFResume/"/>
    <id>http://www.eyrefree.org/EFResume/</id>
    <published>2017-09-14T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.986Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1018190-879153e48fb39720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFResume 是一个普通的简历模板（可能还称不上），用 Swift 进行开发，受 <a href="https://github.com/izuolan/zresume" target="_blank" rel="noopener">zresume</a> 启发，因为 zresume 是基于容器技术的然后需要服务器支持，然而对此技术 EyreFree 表示一窍不通并且囊中羞涩但是觉得这份简历真的非常好看呢，所以就只能自己动手改成静态模板了，😂。设计稿来源于 <a href="https://www.behance.net/gallery/15677411/FREE-Resume-Template" target="_blank" rel="noopener">FREE Resume Template</a>。欢迎大家提 Issue 和 PR，希望能和大家一起改进这份简历，然后好用的话望大佬们赏个 Star，🙏，有问题可以来撩我。</p><blockquote><p><a href="https://github.com/EyreFree/EFResume/blob/master/README.md" target="_blank" rel="noopener">English Introduction</a></p></blockquote><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p><a href="https://github.com/EyreFree/EFResume" target="_blank" rel="noopener">https://github.com/EyreFree/EFResume</a></p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f54ae220436583f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://eyrefree.github.io/EFResume/" target="_blank" rel="noopener">https://eyrefree.github.io/EFResume/</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>XCode 8.0+</li><li>Swift 3.0+</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>唔，首先需要安装 Xcode；</li><li>利用 <code>git clone</code> 命令下载本仓库；</li><li>随后打开 core 目录下的 <code>EFResume.xcworkspace</code> 编译即可。</li></ol><p>或执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:EyreFree/EFResume.git; <span class="built_in">cd</span> EFResume/core; open EFResume.xcworkspace</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>用 Xcode 打开工程；</li><li>打开 main.swift 文件，编辑 input 函数中对应的文本，将信息修改为自己的即可；</li><li>编辑完成后直接编译即可；</li><li>打开 docs 目录下的 index.html 可在本地进行预览；</li><li>将本地变更提交到远端 Git 仓库；</li><li>打开 GitHub 的 Pages 服务，选择 /docs 路径作为根路径，即可生成在线简历同时获得 URL 地址。</li><li>祝好运，👍</li></ol><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>EyreFree, eyrefree@eyrefree.org</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/1018190-4922d1f639709d4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFResume 基于 GPLv3 协议进行分发和使用，更多信息参见协议文件。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/09/14/2017-09-14-EFResume/">http://www.eyrefree.org/2017/09/14/2017-09-14-EFResume/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1018190-879153e48fb39720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="Resume" scheme="http://www.eyrefree.org/tags/Resume/"/>
    
  </entry>
  
  <entry>
    <title>iOS Markdown 转换及预览</title>
    <link href="http://www.eyrefree.org/EFMarkdown/"/>
    <id>http://www.eyrefree.org/EFMarkdown/</id>
    <published>2017-08-27T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.986Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个开发人员，日常经常会需要编写各种各样的文档／材料之类的，个人非常喜欢用 Markdown 来完成这些工作，Markdown 的优点就不再赘述了，大家应该都有过了解，不过目前 iOS 原生并没有提供任何对 Markdown 的支持。所以最近基于 cmark-gfm 把 Markdown 转 HTML 的功能封装了一遍，并且在原有基础上添加了对列表 table 的支持，同时利用 WKWebView 做了一个可直接展示 Markdown 的 View，方便以后使用，现已开源到 GitHub 基于 WTFPL 协议进行分发，需要的同学可以自取。</p><p>项目地址：<a href="https://github.com/EyreFree/EFMarkdown" target="_blank" rel="noopener">https://github.com/EyreFree/EFMarkdown</a></p><hr><p><img src="http://upload-images.jianshu.io/upload_images/1018190-4e62a5fdcac2b5c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFMarkdown 是一个轻量级的 Markdown 库，可以用来将 Markdown 转为 HTML，也可以用来直接展示 Markdown 对其进行预览。</p><blockquote><p><a href="https://github.com/EyreFree/EFMarkdown/blob/master/README.md" target="_blank" rel="noopener">English Introduction</a></p></blockquote><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><table><thead><tr><th style="text-align:center">sample1</th><th style="text-align:center">sample2</th><th style="text-align:center">sample3</th><th style="text-align:center">sample4  </th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-da0a10c955e06239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-6812167f568aef5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-64e5e2ae106fb89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-90d2e5d82627276b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>利用 <code>git clone</code> 命令下载本仓库；</li><li>利用 cd 命令切换到 Example 目录下，执行 <code>pod install</code> 命令；</li><li>随后打开 <code>EFMarkdown.xcworkspace</code> 编译即可。</li></ol><p>或执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:EyreFree/EFMarkdown.git; <span class="built_in">cd</span> EFMarkdown/Example; pod install; open EFMarkdown.xcworkspace</span><br></pre></td></tr></table></figure><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>XCode 8.0+</li><li>Swift 3.0+</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>EFMarkdown 可以通过 <a href="http://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a> 进行获取。只需要在你的 Podfile 中添加如下代码就能实现引入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &quot;EFMarkdown&quot;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-将-Markdown-转为-HTML"><a href="#1-将-Markdown-转为-HTML" class="headerlink" title="1. 将 Markdown 转为 HTML"></a>1. 将 Markdown 转为 HTML</h3><p>你可以利用 <code>EFMarkdown</code> 轻松实现 Markdown 字符串到 HTML 字符串地转换，示例代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> markdown = <span class="string">"# Hello"</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">""</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    html = <span class="keyword">try</span> <span class="type">EFMarkdown</span>().markdownToHTML(markdown, options: <span class="type">EFMarkdownOptions</span>.safe)</span><br><span class="line">    <span class="built_in">print</span>(html) <span class="comment">// 这里会输出 "&lt;h1&gt;Hello&lt;/h1&gt;\n"</span></span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对-Markdown-进行预览"><a href="#2-对-Markdown-进行预览" class="headerlink" title="2. 对 Markdown 进行预览"></a>2. 对 Markdown 进行预览</h3><p>你可以利用 <code>EFMarkdownView</code> 实现对 Markdown 字符串的预览，示例代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> screenSize = <span class="type">UIScreen</span>.main.bounds</span><br><span class="line"><span class="keyword">let</span> markView = <span class="type">EFMarkdownView</span>()</span><br><span class="line">markView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">20</span>, width: screenSize.width, height: screenSize.height - <span class="number">20</span>)</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(markView)</span><br><span class="line">markView.load(markdown: testMarkdownFileContent(), options: [.<span class="keyword">default</span>]) &#123;</span><br><span class="line">    [<span class="keyword">weak</span> <span class="keyword">self</span>] (<span class="number">_</span>, <span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="comment">// 可选：你可以通过在此处传入一个百分比来改变字体大小</span></span><br><span class="line">        markView.setFontSize(percent: <span class="number">128</span>)</span><br><span class="line">        printLog(<span class="string">"load finish!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选项"><a href="#3-选项" class="headerlink" title="3. 选项"></a>3. 选项</h3><p>你可以通过传入不同的选项来控制底层 <code>cmark</code> 对 Markdown 字符串的处理，默认传入的值为 <code>safe</code>。</p><p>可选的值有以下这些：</p><ul><li>default</li><li>sourcePos</li><li>hardBreaks</li><li>safe</li><li>noBreaks</li><li>validateUTF8</li><li>smart</li><li>githubPreLang</li><li>liberalHtmlTag</li></ul><p>更多关于这些选项的信息，可以参考 <a href="https://github.com/github/cmark" target="_blank" rel="noopener"><code>cmark</code></a>。</p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>EyreFree, eyrefree@eyrefree.org</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="http://upload-images.jianshu.io/upload_images/1018190-17002c4b490b0b86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>EFMarkdown 基于 WTFPL 协议进行分发和使用，更多信息参见协议文件。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/08/27/2017-08-27-EFMarkdown/">http://www.eyrefree.org/2017/08/27/2017-08-27-EFMarkdown/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个开发人员，日常经常会需要编写各种各样的文档／材料之类的，个人非常喜欢用 Markdown 来完成这些工作，Markdown 的优点就不再赘述了，大家应该都有过了解，不过目前 iOS 原生并没有提供任何对 Markdown 的支持。所以最近基于 cmark-gfm 把
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="Markdown" scheme="http://www.eyrefree.org/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Swift 流水账：踩到一个 Enum 坑（并不是</title>
    <link href="http://www.eyrefree.org/SwiftEnum/"/>
    <id>http://www.eyrefree.org/SwiftEnum/</id>
    <published>2017-08-15T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.986Z</updated>
    
    <content type="html"><![CDATA[<p>今天，天气晴朗，阳光明媚，我像往常一样赖床赖到了九点半，然后在最后一遍起床闹钟的催促声中穿起了衣服，飞一般地冲出了出租屋，蹬上小区门口的小黄，一路冲刺，在即将迟到的前 1s 到达了工位，和平的日常呢。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-ee973c8209f8dd57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>熟练地打开 XCode（我为什么这么熟练呢…）启动项目，开始继续完成产品大大昨天下达的任务。这时，一个枚举进入了我的视野范围内，枚举常量数据类型是 NSUInteger，哼哼，用表驱动法结合 rawValue 的方式，就能优雅地实现这个需求了，完美。</p><p>然而，跑了一下居然发生了运行时错误炸掉了…没道理啊，这也能炸…</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-59ea929cb1b4246e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EyreFree 眉头一皱，发现事情并不简单"></p><p>点开这个枚举类型，仔细观察了起来…然后发现了一个坑…（应该是我年少无知…</p><p>下面，我带着大家一起跳进这个坑…哦不，一起复现一下这个问题：</p><h3 id="1-新建一个-OC-的-Pod-库"><a href="#1-新建一个-OC-的-Pod-库" class="headerlink" title="1. 新建一个 OC 的 Pod 库"></a>1. 新建一个 OC 的 Pod 库</h3><p>首先，我们需要新建一个 OC 的 Pod 库，然后在其中定义一个枚举类型，指定枚举值从 2 开始（反正不要是默认的 0 就行），大概这个样子就行了：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, TestEnum) &#123;</span><br><span class="line">    TestEnumA = <span class="number">2</span>,</span><br><span class="line">    TestEnumB,</span><br><span class="line">    TestEnumC,</span><br><span class="line">    TestEnumD,</span><br><span class="line">    TestEnumE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> TestEnum EFTestEnumType;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2529d4f32de43374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><h3 id="2-新建一个-Swift-工程"><a href="#2-新建一个-Swift-工程" class="headerlink" title="2. 新建一个 Swift 工程"></a>2. 新建一个 Swift 工程</h3><p>然后，我们再建一个新的 Swift 工程（没错，我司项目是 Swift 的…），在其中引入第一步建好的 CocoaPods 库。到这里，我们可以随便找个地方编写如下测试代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(EFTestEnumType.A.rawValue)</span>"</span>)</span><br></pre></td></tr></table></figure><p>先不要执行蛤，大家按住 command 键点击 EFTestEnumType 进入类型定义可以看到如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> : <span class="title">UInt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">B</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">C</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">D</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">E</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">EFTestEnumType</span> = <span class="type">TestEnum</span></span><br></pre></td></tr></table></figure><p>注意到了么，这里通过 Pod 库中的原始 OC 代码转化出的中间 Swift 代码的枚举中，并没有指定枚举值的起始值。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-b2e7873bd027cbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p><h3 id="3-编译运行并观察"><a href="#3-编译运行并观察" class="headerlink" title="3. 编译运行并观察"></a>3. 编译运行并观察</h3><p>然后编译运行，观察测试代码的输出会发现，EFTestEnumType.A.rawValue 的值的确是 2…所以，我在主工程中查看了某个枚举类型的定义，而没有注意到 Pod 库中枚举的原始定义是指定了枚举值的起始值的（很好奇为啥这里不一样，搞这么多幺蛾子…），然后就炸了，数组下标越界，初始化失败，随便来一个都会炸掉了…</p><p>小伙伴们看懂了么…（嘛，如果这是常识的话…请告诉我我好删掉这篇水文…逃…</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-94efe02f989268af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>PS: 文中所用代码可以在 <a href="https://github.com/EyreFree/EFEnumPitDemo" target="_blank" rel="noopener">https://github.com/EyreFree/EFEnumPitDemo</a> 找到。</p><hr><p>更新：</p><p>感谢 <a href="http://www.weibo.com/kemchenj" target="_blank" rel="noopener">@kemchenj</a> 大大的提示，这里应该需要将鼠标悬浮到枚举值之上才可以查看到对应的原始值，反正我还是觉得坑…[摊手]</p><blockquote><p>@kemchenj：看了很久之后终于懂了，其实主要是 Interface 的锅，Interface 里不会显示枚举值的具体原始值，跟 OC 转 Swift 无关，你可以在 Swift 里定义一个相同的枚举，然后进 Xcode 菜单 -&gt; Navigate -&gt; Jump To Generated Interface，这样就可以看到这个 swift 文件的 Interface 了，也不会具体的 rawValue</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/1018190-afadd3defe195ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/08/15/2017-08-15-Swift-Enum/">http://www.eyrefree.org/2017/08/15/2017-08-15-Swift-Enum/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，天气晴朗，阳光明媚，我像往常一样赖床赖到了九点半，然后在最后一遍起床闹钟的催促声中穿起了衣服，飞一般地冲出了出租屋，蹬上小区门口的小黄，一路冲刺，在即将迟到的前 1s 到达了工位，和平的日常呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-image
      
    
    </summary>
    
      <category term="Swift" scheme="http://www.eyrefree.org/categories/Swift/"/>
    
    
      <category term="Enum" scheme="http://www.eyrefree.org/tags/Enum/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Wiki 页面的添加和设置</title>
    <link href="http://www.eyrefree.org/GitHubWiki/"/>
    <id>http://www.eyrefree.org/GitHubWiki/</id>
    <published>2017-07-06T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.985Z</updated>
    
    <content type="html"><![CDATA[<p>目前大家在 GitHub 上发布的项目，一般使用 Markdown 来编写项目文档和 README.md 等。Markdown 一般情况下能够满足我们的文档编写需求，如果使用得当的话，效果也非常棒。不过当项目文档比较长的时候，阅读体验可能就不是那么理想了，这种情况我想大家应该都曾经遇到过。</p><p>GitHub 每一个项目都有一个独立完整的 Wiki 页面，我们可以用它来实现项目信息管理，为项目提供更加完善的文档。我们可以把 Wiki<br> 作为项目文档的一个重要组成部分，将冗长、具体的文档整理成 Wiki，将精简的、概述性的内容，放到项目中或是 README.md 里。</p><h2 id="一-Wiki-简介"><a href="#一-Wiki-简介" class="headerlink" title="一. Wiki 简介"></a>一. Wiki 简介</h2><blockquote><p>Wiki 是一种在网络上开放且可供多人协同创作的超文本系统，由沃德·坎宁安于 1995 年首先开发，这种超文本系统支持面向社群的协作式写作，同时也包括一组支持这种写作。Wiki 站点可以有多人（甚至任何访问者）维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。</p></blockquote><p>上面这段描述引用自 <a href="http://baike.baidu.com/item/wiki/97755" target="_blank" rel="noopener">百度百科</a>，嗯，实际上百度百科本身也是一个 Wiki，最著名的 Wiki 大概是是 <a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91" target="_blank" rel="noopener">维基百科</a> 了吧。</p><p>然后 Wiki 页面效果大概可以参考 <a href="https://github.com/onevcat/Kingfisher/wiki" target="_blank" rel="noopener">Kingfisher</a>，看起来还是非常棒的：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-51b1b1ab89fc7d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kingfisher 的 Wiki 页面"></p><h2 id="二-Wiki-的开启和关闭"><a href="#二-Wiki-的开启和关闭" class="headerlink" title="二. Wiki 的开启和关闭"></a>二. Wiki 的开启和关闭</h2><p>GitHub 项目的 Wikis 功能默认是开启的，如果你没有找到 Wiki 选项卡，可能是因为该项目关闭了 Wikis 选项，在项目 Setting 中将其选中即可，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-55bf326e65831bdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Wikis 开关"></p><p>如果在之后某一天决定不再继续使用 Wikis 也可以通过取消该功能的勾选将其关闭，即使已经添加了 Wiki 页面也可以。并且会保存之前的 Wiki 页面内容，即关闭 Wiki 功能并不会清除内容，还可以随时再打开。</p><h2 id="三-创建和编辑页面"><a href="#三-创建和编辑页面" class="headerlink" title="三. 创建和编辑页面"></a>三. 创建和编辑页面</h2><p>GitHub 的 Wiki 页面在如图所示选项卡下，默认应该是开启的，但是是空的，我们可以点击中间那个绿色的 <code>Create the first page</code> 按钮创建一个页面。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-fadd06a0b50a299b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 Wiki 页面"></p><p>如果你没有找到 Wiki 选项卡，可能是因为该项目关闭了 Wikis 选项，在项目 Setting 中将其选中即可，参考上文内容。</p><p>点击 <code>Create the first page</code> 按钮后会进入 Create new page 页面：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-b5082f398cf04cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Create new page"></p><p>从上往下进行介绍，顶部的输入框是页面标题；Edit mode 控制编辑页面的标记语言类型，这里默认的是 Markdown，支持的类型如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-8955fdc3169fe36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Edit mode 下拉列表"></p><p>中间的是页面内容，我们可以用 Edit mode 选择的语法在这里编写页面内容；底部编辑框用来输入本次编辑保存时的提交信息；编辑完成后点击 <code>Save Page</code> 按钮即可保存，唔，保存前可以先切换到 Preview 选项卡下进行预览，看一下效果是否是自己想要的。</p><p>然后保存我们新建的页面，大概会是如下效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f3bbc7ae3f87d86a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建页面完成"></p><p>点击右上角的 <code>Edit</code> 按钮可以对当前页面进行编辑，也可以点击 <code>New Page</code> 按钮继续添加新的页面。</p><p>唔，这里有一点需要注意的是，默认的主页标题必须为 Home，如果不存在标题为 Home 的页面，切换到项目的 Wiki 选项卡时，会显示一个所有页面组成的列表。所以我们的主页必须以 Home 为标题。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-ac17b4a9220d4503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>目前好像没什么内容，感觉比较空额，不过没关系，接下来我们会一步步完善。</p><h2 id="四-添加页脚"><a href="#四-添加页脚" class="headerlink" title="四. 添加页脚"></a>四. 添加页脚</h2><p>点击 Wiki 页面底部的 <code>Add a custom footer</code> 按钮，进入新建页脚页面，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-898c1c9b8ff154b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add a custom footer"></p><p>新建页脚页面实际上就是一个普通的 Create new page 页面，不过标题需要设为 _Footer 并且不能修改（如果修改了就不会被当作页脚来处理了）。</p><p>我们可以参考 Kingfisher 的页脚代码，放置多个超链接在这里供读者在阅读完某一页后快速跳转到关键的章节或页面去，具体代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Installation</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/Installation-Guide</span>) - [<span class="string">Cheat Sheet</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/Cheat-Sheet</span>) - [<span class="string">FAQ</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/FAQ</span>) - [<span class="string">API Reference</span>](<span class="link">http://onevcat.github.io/Kingfisher/</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1018190-ff95cc5b1f8caeb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kingfisher 页脚效果"></p><p>当然也可以放一些奇怪的东西，比如，这样的：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-58c20385b24679b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="+1s"></p><p>如上图所示，点击页脚右侧的编辑按钮，就可以对页脚进行编辑啦，很方便。</p><h2 id="五-添加侧边栏"><a href="#五-添加侧边栏" class="headerlink" title="五. 添加侧边栏"></a>五. 添加侧边栏</h2><p>点击右侧的 <code>Add a custom sidebar</code> 按钮可以添加侧边栏，和页脚同理，页面名为特殊的 _Sidebar：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d71291cb72c041e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Add a custom sidebar"></p><p>我们可以参考 Kingfisher 的侧边栏实现，代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## Getting Started</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Getting Started with Kingfisher</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/Getting-Started-with-Kingfisher</span>)</span><br><span class="line"><span class="code">    * [Install Kingfisher](https://github.com/onevcat/Kingfisher/wiki/Installation-Guide)</span></span><br><span class="line"><span class="code">    * [Cheat Sheet](https://github.com/onevcat/Kingfisher/wiki/Cheat-Sheet)</span></span><br><span class="line"><span class="bullet">* </span>[<span class="string">API Reference</span>](<span class="link">http://onevcat.github.io/Kingfisher/</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## Migration Guide</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">3.0 Migration Guide</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/Kingfisher-3.0-Migration-Guide</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">2.0 Migration Guide</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/Kingfisher-2.0-Migration-Guide</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## Communication</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">FAQ</span>](<span class="link">https://github.com/onevcat/Kingfisher/wiki/FAQ</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Ask a question</span>](<span class="link">http://stackoverflow.com/search?q=kingfisher</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Submit an issue</span>](<span class="link">https://github.com/onevcat/Kingfisher/issues/new</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="string">Open a pull request</span>](<span class="link">https://github.com/onevcat/Kingfisher/compare</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## Information</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">Change Log</span>](<span class="link">https://github.com/onevcat/Kingfisher/blob/master/CHANGELOG.md</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1018190-eb156bb5531e33ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kingfisher 的侧边栏"></p><p>这里的话可以自己适当摸索一下，调整标题层级等样式，以获得一个自己比较满意的展示效果。同样的，点击侧边栏右上角的编辑按钮可以对快速侧边栏进行在线编辑。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-9935667a3e9db865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="侧边栏编辑按钮"></p><h2 id="六-查看编辑历史"><a href="#六-查看编辑历史" class="headerlink" title="六. 查看编辑历史"></a>六. 查看编辑历史</h2><p>进入某个页面的编辑页面，点击右上角的 <code>Page History</code> 按钮，可以查看该页面的编辑历史，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-4b8793bbd61f8087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Page History 按钮"></p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f4738bce2c4201fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑历史页面"></p><h2 id="七-权限控制"><a href="#七-权限控制" class="headerlink" title="七. 权限控制"></a>七. 权限控制</h2><p>那么问题来了，既然是 Wiki 的话，为啥以上这些内容完全是项目所有者一个人手撸呢，完全没有体现出「多人协作」的特性啊喂。</p><p>嗯，GitHub Wiki 是可以开放给所有人编辑权限的，不过默认是只有项目所有者和合作者才有权限编辑的，只要到 Setting 中将 Restrict editing to collaborators only 选项去除勾选即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-eeda3279fe26cc8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Restrict editing to collaborators only"></p><p>这样的话，只要有 GitHub 账号的用户，都可以对该项目的 Wiki 进行编辑。如果怕被胡乱篡改，不想开放编辑权限的话，还是保持勾选好了。</p><h2 id="八-本地编辑"><a href="#八-本地编辑" class="headerlink" title="八. 本地编辑"></a>八. 本地编辑</h2><p>唔，上文内容一直在介绍 Wiki 的在线编辑，实际上 Wiki 是一个单独的 Git 仓库，可以 Clone 到本地进行操作</p><h3 id="1-Wiki-仓库下载"><a href="#1-Wiki-仓库下载" class="headerlink" title="1. Wiki 仓库下载"></a>1. Wiki 仓库下载</h3><p>细心的同学应该已经注意到了，Wiki 的右下角处有当前 Wiki 的 Git 仓库地址（我们也可以通过该方法下载他人所属的 Wiki 页面的源代码）：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-23f30e41d4d6981b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Wiki 仓库地址"></p><p>Kingfisher 的 Wiki 仓库结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-6795f9e7aaa9440a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kingfisher Wiki 结构"></p><p>接下来就可以直接对 Wiki 页面源文件进行编辑了，实际上就是一堆 Markdown 文件的组合（或者其他比标记语言，看你选的是啥了）。</p><h3 id="2-本地预览"><a href="#2-本地预览" class="headerlink" title="2. 本地预览"></a>2. 本地预览</h3><p>我们在本地手动编辑编辑完成后，只能通过 push 到 GitHub 的方式进行预览，非常不方便，这个时候，就需要借助一个叫 <a href="https://github.com/gollum/gollum" target="_blank" rel="noopener">gollum</a> 的工具了。</p><p>Gollum 是 GitHub 上用到的 Wiki 引擎，使用它可以在本地上搭建一个类似的GitHub Wiki 的网站，对本地的 Wiki 页面进行快速预览。执行以下命令即可安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install gollum</span><br></pre></td></tr></table></figure><p>安装完成后，将路径切换到 Wiki 的 Git 仓库下然后执行 <code>gollum</code> 命令，然后访问 <a href="http://127.0.0.1:4567/" target="_blank" rel="noopener">http://127.0.0.1:4567/</a> 即可进行预览。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-34b7d6d79ffd94cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gollum 预览"></p><h2 id="九-其他"><a href="#九-其他" class="headerlink" title="九. 其他"></a>九. 其他</h2><p>Wiki 不仅仅可以作为项目辅助工具来用，你也可以把它当作一个个人信息知识库来使用，不需要搭建，不需要部署，无需付费，方便快捷，更多功鞥大家可以自行开发。</p><p>如果你觉得上文的报道，哦不，描述可能有偏差，<a href="https://help.github.com/categories/wiki/" target="_blank" rel="noopener">GitHub Wiki 的帮助文档</a> 也许能给你带来一些帮助。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/07/06/2017-07-06-GitHub-Wiki-Introduction/">http://www.eyrefree.org/2017/07/06/2017-07-06-GitHub-Wiki-Introduction/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前大家在 GitHub 上发布的项目，一般使用 Markdown 来编写项目文档和 README.md 等。Markdown 一般情况下能够满足我们的文档编写需求，如果使用得当的话，效果也非常棒。不过当项目文档比较长的时候，阅读体验可能就不是那么理想了，这种情况我想大家应
      
    
    </summary>
    
      <category term="GitHub" scheme="http://www.eyrefree.org/categories/GitHub/"/>
    
    
      <category term="Wiki" scheme="http://www.eyrefree.org/tags/Wiki/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 项目徽章的添加和设置</title>
    <link href="http://www.eyrefree.org/GitHubBadge/"/>
    <id>http://www.eyrefree.org/GitHubBadge/</id>
    <published>2017-05-01T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.985Z</updated>
    
    <content type="html"><![CDATA[<p>许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。</p><p>自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介绍项目相关信息呢？用一些通用的小图标来描述项目相关信息不失为一种很棒的选择，几个好看的徽标能够为自己的项目说明增色不少！</p><h1 id="一-徽标简介"><a href="#一-徽标简介" class="headerlink" title="一. 徽标简介"></a>一. 徽标简介</h1><p>GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。</p><p>徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-3489b47031ed2017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一枚普通的徽标"></p><p>GitHub 徽标的官方网站是 <a href="http://shields.io/" target="_blank" rel="noopener">http://shields.io/</a>，我萌可以在官网预览绝大部分的徽标样式，然后选择自己喜欢的（当然首先需要适用于自己的目标项目）徽标，添加到自己的项目文档中去。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-b2676f0571e5684c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Shields.IO"></p><p>下面贴出几个栗子以供参考：</p><ul><li>正在学习的 ReSwift</li></ul><p><a href="https://travis-ci.org/ReSwift/ReSwift" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/ReSwift/ReSwift/master.svg?style=flat-square" alt="Build Status"></a> <a href="http://codecov.io/github/ReSwift/ReSwift" target="_blank" rel="noopener"><img src="https://img.shields.io/codecov/c/github/ReSwift/ReSwift.svg?style=flat-square" alt="Code coverage status"></a> <a href="https://cocoapods.org/pods/ReSwift" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/v/ReSwift.svg?style=flat-square" alt="CocoaPods Compatible"></a> <a href="https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/platform-ios%20%7C%20osx%20%7C%20tvos%20%7C%20watchos-lightgrey.svg?style=flat-square" alt="Platform support"></a> <a href="https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square" alt="License MIT"></a></p><ul><li>大名鼎鼎的 Kingfisher</li></ul><p align="center"><br><br><img src="https://raw.githubusercontent.com/onevcat/Kingfisher/master/images/logo.png" alt="Kingfisher" title="Kingfisher" width="557"><br><br></p><p align="center"><br><a href="https://travis-ci.org/onevcat/Kingfisher" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/onevcat/Kingfisher/master.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"></a><br><a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"></a><br><a href="https://codebeat.co/projects/github-com-onevcat-kingfisher" target="_blank" rel="noopener"><img alt="codebeat badge" src="https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"></a><br><img src="https://img.shields.io/badge/made%20with-%3C3-orange.svg"><br></p><ul><li>家喻户晓的 Alamofire</li></ul><p><img src="https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png" alt="Alamofire: Elegant Networking in Swift"></p><p><a href="https://travis-ci.org/Alamofire/Alamofire" target="_blank" rel="noopener"><img src="https://travis-ci.org/Alamofire/Alamofire.svg?branch=master" alt="Build Status"></a><br><a href="https://img.shields.io/cocoapods/v/Alamofire.svg" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/v/Alamofire.svg" alt="CocoaPods Compatible"></a><br><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage Compatible"></a><br><a href="http://cocoadocs.org/docsets/Alamofire" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat" alt="Platform"></a><br><a href="http://twitter.com/AlamofireSF" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat" alt="Twitter"></a><br><a href="https://gitter.im/Alamofire/Alamofire?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Alamofire/Alamofire.svg" alt="Gitter"></a></p><p>徽标并不是添加的越多越好，合理地选择适合项目的徽标做具有针对性地添加才是理性的做法，像 <a href="https://github.com/EyreFree/EFQRCode" target="_blank" rel="noopener">EFQRCode</a> 这样堆积徽标的无脑行为并不是十分可取，在这里提出这一点，希望大家不要盲目追求数量。</p><ul><li>腊鸡 EFQRCode</li></ul><p><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/assets/EFQRCode.jpg" alt=""></p><p align="center"><br><a href="https://travis-ci.org/EyreFree/EFQRCode" target="_blank" rel="noopener"><img src="http://img.shields.io/travis/EyreFree/EFQRCode.svg"></a><br><a href="https://codecov.io/gh/EyreFree/EFQRCode" target="_blank" rel="noopener"><img src="https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://cocoapods.org/pods/EFQRCode" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/v/EFQRCode.svg?style=flat"></a><br><a href="http://cocoapods.org/pods/EFQRCode" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/p/EFQRCode.svg?style=flat"></a><br><a href="https://github.com/apple/swift" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/language-swift-orange.svg"></a><br><a href="https://codebeat.co/projects/github-com-eyrefree-efqrcode-master" target="_blank" rel="noopener"><img src="https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f"></a><br><a href="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/l/EFQRCode.svg?style=flat"></a><br><a href="https://gitter.im/EFQRCode/Lobby" target="_blank" rel="noopener"><img src="https://badges.gitter.im/EyreFree/EFQRCode.svg"></a><br><a href="https://twitter.com/EyreFree777" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?style=flat"></a><br><a href="http://weibo.com/eyrefree777" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=flat"></a><br></p><p>当然如果个人比较喜欢的话，请随意添加。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-bd12202658a6a391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请随意"></p><h1 id="二-常用徽标添加"><a href="#二-常用徽标添加" class="headerlink" title="二. 常用徽标添加"></a>二. 常用徽标添加</h1><p>常用的徽标主要有持续集成状态、项目版本信息、代码测试覆盖率、项目支持平台、项目语言、代码分析等，下面我萌就来依次添加这些可爱的徽标！</p><h2 id="1-持续集成状态"><a href="#1-持续集成状态" class="headerlink" title="1. 持续集成状态"></a>1. 持续集成状态</h2><p>持续集成的话推荐 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，针对开源项目免费，所以你的私有项目无法享受到免费的持续构建服务，不过我们的目的貌似就是给开源项目添加徽标。</p><p>同类型的产品还有 <a href="https://circleci.com" target="_blank" rel="noopener">CircleCI</a>，不过目前跑 OS X 项目需要额外付费，免费版提供一个 Linux 项目队列，作为非付费用户在这里不多做评价，大佬们可以自己试下。其他还有诸如 <a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a><br> 和 <a href="https://codeship.com/" target="_blank" rel="noopener">Codeship</a> 等，大家可以在 <a href="http://shields.io/" target="_blank" rel="noopener">http://shields.io/</a> 的 <code>Build</code> 这一栏自行翻阅。</p><p>接下来就是 Travis CI 的集成工作了，首先打开 <a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> 注册一个 Travis-CI 账号，可以通过 GitHub 账户直接登陆。</p><p>然后参考 <a href="https://docs.travis-ci.com/user/getting-started/" target="_blank" rel="noopener">官方文档</a>，根据你的项目语言或类型选择具体的配置方式，主要就是在项目中添加一个 <code>.travis.yml</code> 配置文件，告诉 Travis CI 怎样对你的项目进行编译或测试。这里有一个 Swift CocoaPods 库的集成示例，可以参考一下：<a href="http://www.jianshu.com/p/beaa9ec9183d" target="_blank" rel="noopener">http://www.jianshu.com/p/beaa9ec9183d</a>。</p><p>然后徽标图片地址是这个样子的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://img.shields.io/travis/&#123;GitHub 用户名&#125;/&#123;项目名称&#125;.svg</span><br></pre></td></tr></table></figure><p>将上面 URL 中的 {GitHub 用户名} 和 {项目名称} 替换为你的即可，再加上该项目在 Travis CI 上的地址，以 Alamofire 为例，最后集成完成的 Markdown 代码和效果大概是这个样子：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![</span>](<span class="link">https://travis-ci.org/Alamofire/Alamofire.svg?branch=master</span>)](<span class="link">https://travis-ci.org/Alamofire/Alamofire</span>)</span><br></pre></td></tr></table></figure><p><a href="https://travis-ci.org/Alamofire/Alamofire" target="_blank" rel="noopener"><img src="https://travis-ci.org/Alamofire/Alamofire.svg?branch=master" alt=""></a></p><p>当然如果你的编译没跑过或者发生错误之类的，会出现其他的状态，比如酱紫的：</p><p><img src="https://img.shields.io/codeship/d6c1ddd0-16a3-0132-5f85-2e35c05e22b1.svg" alt=""></p><p><img src="https://img.shields.io/vso/build/larsbrinkhoff/953a34b9-5966-4923-a48a-c41874cfb5f5/1.svg" alt=""></p><p><img src="https://img.shields.io/snap-ci/ThoughtWorksStudios/eb_deployer/master.svg" alt=""></p><p>这里需要指出的是，开源项目的 Travis CI 也是公开的，包括日志和历史记录在内，都是针对所有人可见的，所以小伙伴们一定不要把密码、私钥等重要信息暴露了。</p><h2 id="2-项目下载量"><a href="#2-项目下载量" class="headerlink" title="2. 项目下载量"></a>2. 项目下载量</h2><p>项目被下载的次数，这个的话各个平台的统计都是独立的，比如发布在 CocoaPods 的项目下载量徽标图片地址如下，以 AFNetworking 为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总下载量：https://img.shields.io/cocoapods/dt/AFNetworking.svg</span><br><span class="line">月下载量：https://img.shields.io/cocoapods/dm/AFNetworking.svg</span><br><span class="line">周下载量：https://img.shields.io/cocoapods/dw/AFNetworking.svg</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://img.shields.io/cocoapods/dt/AFNetworking.svg" alt=""><br><img src="https://img.shields.io/cocoapods/dm/AFNetworking.svg" alt=""><br><img src="https://img.shields.io/cocoapods/dw/AFNetworking.svg" alt=""></p><p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 AFNetworking 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 <a href="http://shields.io/" target="_blank" rel="noopener">http://shields.io/</a> 的 <code>Downloads</code> 一栏。</p><h2 id="3-项目版本信息"><a href="#3-项目版本信息" class="headerlink" title="3. 项目版本信息"></a>3. 项目版本信息</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/cocoapods/v/&#123;项目名称&#125;.svg?style=flat</span><br></pre></td></tr></table></figure><p>以 Alamofire 为例，Markdown 代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat" alt=""></p><p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 <a href="http://shields.io/" target="_blank" rel="noopener">http://shields.io/</a> 的 <code>Version</code> 一栏，这里提供一个可以查询已发布的各种包的版本号徽标地址的网站 <a href="https://badge.fury.io/" target="_blank" rel="noopener">https://badge.fury.io/</a>，可以轻松获取对应包的徽标代码，如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a6257e9b997c4a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果你的发布工具不提供项目版本信息的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/&#123;发布方式&#125;-&#123;版本号&#125;-519dd9.svg</span><br></pre></td></tr></table></figure><p>将 {发布方式} 和 {版本号} 替换为你的项目目前的发布方式和版本号即可，例如通过 360 应用商店发布，发布版本号为 v1.2.3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg" alt=""></p><h2 id="4-代码测试覆盖率"><a href="#4-代码测试覆盖率" class="headerlink" title="4. 代码测试覆盖率"></a>4. 代码测试覆盖率</h2><p>代码测试覆盖率的话推荐 <a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a>。同类产品有 <a href="https://coveralls.io/" target="_blank" rel="noopener">Coveralls</a>，不过网站风格略复古，文档也不详细，安装过程也复杂，需要配置一大堆奇怪的东西，遂不推荐。</p><p>同样的，Codecov 可以直接使用 GitHub 账号登陆，需要结合 Travis CI 使用，在 <code>.travis.yml</code> 文件中添加一个回调触发 Codecov 的刷新，同时需要打开工程中的测试覆盖信息收集，XCode 中的设置如下</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a1fceb0028ce645a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>更多信息可参考 <a href="https://docs.codecov.io/docs" target="_blank" rel="noopener">官方文档</a> 和 <a href="https://github.com/codecov" target="_blank" rel="noopener">示例</a>。</p><p>然后，我们就可以在 Setting 中的 Badge 一栏找到添加图标的代码啦：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-95306d0d263235c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>最终效果如下：</p><p><a href="https://codecov.io/gh/EyreFree/EFQRCode" target="_blank" rel="noopener"><img src="https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg" alt="codecov"></a></p><h2 id="5-项目支持平台"><a href="#5-项目支持平台" class="headerlink" title="5. 项目支持平台"></a>5. 项目支持平台</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/cocoapods/p/&#123;项目名称&#125;.svg?style=flat</span><br></pre></td></tr></table></figure><p>以 Alamofire 为例，Markdown 代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat" alt=""></p><p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供项目支持平台的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/platform-&#123;项目支持平台&#125;-lightgrey.svg</span><br></pre></td></tr></table></figure><p>将 {项目支持平台} 替换为你的项目目前的版本号即可，例如 ios：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/platform-ios-lightgrey.svg)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/platform-ios-lightgrey.svg" alt=""></p><h2 id="6-项目语言"><a href="#6-项目语言" class="headerlink" title="6. 项目语言"></a>6. 项目语言</h2><p>嗯，这个完全是用自定义徽标实现的，具体可参考下文自定义徽标一节，这里给出徽标代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/language-&#123;项目语言&#125;-&#123;背景色&#125;.svg</span><br></pre></td></tr></table></figure><p>将 {项目语言} 和 {背景色} 替换为你的项目目前的语言和你想要的背景色即可，这里以 Swift 为例，我们用上 Swift 官方橘色：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/language-swift-orange.svg)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/language-swift-orange.svg" alt=""></p><p>完美!</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7aaab9c7de41a78c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift"></p><h2 id="7-代码分析"><a href="#7-代码分析" class="headerlink" title="7. 代码分析"></a>7. 代码分析</h2><blockquote><p><a href="https://codebeat.co/" target="_blank" rel="noopener">Codebeat</a> 可以计算全局项目评分、GPA、和不同命名空间的等级来帮助您量化技术债务和发现重构机会，你唯一需要做的就是连接你的 Github 库，获得反馈就好了。</p></blockquote><p>嗯，上面是官方自述，大概意思就是每次 push 或者 merge 之后会对代码进行分，给出评分，然后告诉你哪些地方复杂度过高需要进行重构之类的。用 GitHub 登陆后绑定项目即可，无需对原有项目进行修改（其实是 codebeat 在你的项目设置里加了一个 Webhook，通知它重新计算评分）。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-271c429613a8d34e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Webhooks"></p><p>照着引导巴拉巴拉一顿操作之后就可以获取图标啦，在项目的 Setting 中可以获取徽标代码，自己复制出来就可以。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-080b0705f241d072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting"></p><p>最终效果如下：</p><p><a href="https://codebeat.co/projects/github-com-eyrefree-efqrcode-master" target="_blank" rel="noopener"><img src="https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f" alt="codebeat badge"></a></p><h2 id="8-开源协议类型"><a href="#8-开源协议类型" class="headerlink" title="8. 开源协议类型"></a>8. 开源协议类型</h2><p>这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/cocoapods/l/&#123;项目名称&#125;.svg?style=flat</span><br></pre></td></tr></table></figure><p>以 Alamofire 为例，Markdown 代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat" alt=""></p><p>如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供开源协议类型的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/license-&#123;协议名称&#125;-000000.svg</span><br></pre></td></tr></table></figure><p>将 {协议名称} 替换为你的项目所使用的协议名称即可，例如 MIT：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/license-MIT-000000.svg)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/license-MIT-000000.svg" alt=""></p><h1 id="三-自定义徽标"><a href="#三-自定义徽标" class="headerlink" title="三. 自定义徽标"></a>三. 自定义徽标</h1><h2 id="1-标题／内容／颜色／链接"><a href="#1-标题／内容／颜色／链接" class="headerlink" title="1. 标题／内容／颜色／链接"></a>1. 标题／内容／颜色／链接</h2><p>如果以上这些徽标没有满足你的需求，我们还可以定制自己的个性化徽标，<code>shields.io</code> 提供了添加自定义徽标的功能，通过修改如下 URL 即可获取自定义徽标图片：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg</span><br></pre></td></tr></table></figure><p>{徽标标题}：徽标左半部分的文本（短线：–，下划线：__，空格： 或_）；<br>{徽标内容}：徽标右半部分的文本，同上；<br>{徽标颜色}：徽标右半部分背景颜色，可以是 red、green、blue 等颜色英文单词，也可以直接写十六进制的颜色值，如 ff69b4，示例如下：</p><p><img src="https://img.shields.io/badge/color-brightgreen-brightgreen.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-green-green.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-yellowgreen-yellowgreen.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-yellow-yellow.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-orange-orange.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-red-red.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-lightgrey-lightgrey.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-blue-blue.svg?maxAge=2592000" alt=""><br><img src="https://img.shields.io/badge/color-ff69b4-ff69b4.svg?maxAge=2592000" alt=""></p><p>将其中的 {徽标标题}、{徽标内容}、{徽标颜色} 分别替换为需要的内容即可，例如我的微博徽标图片地址如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://img.shields.io/badge/weibo-@EyreFree-red.svg</span><br></pre></td></tr></table></figure><p>再结合我的微博地址 <a href="http://weibo.com/eyrefree777" target="_blank" rel="noopener">http://weibo.com/eyrefree777</a> 后完整徽标代码和效果如下（如果这段代码用在 GitHub 的话，点击该徽标会打开对应的 URL 地址，即直接跳到我的微博）：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![</span>](<span class="link">https://img.shields.io/badge/weibo-@EyreFree-red.svg</span>)](<span class="link">http://weibo.com/eyrefree777</span>)</span><br></pre></td></tr></table></figure><p><a href="http://weibo.com/eyrefree777" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/weibo-@EyreFree-red.svg" alt=""></a></p><p>同理我的推特徽标代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![</span>](<span class="link">https://img.shields.io/badge/twitter-@EyreFree777-blue.svg</span>)](<span class="link">https://twitter.com/EyreFree777</span>)</span><br></pre></td></tr></table></figure><p><a href="https://twitter.com/EyreFree777" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg" alt=""></a></p><h2 id="2-附加参数"><a href="#2-附加参数" class="headerlink" title="2. 附加参数"></a>2. 附加参数</h2><p>可以在徽标图片 URL 后面带上一些参数来控制徽标的样式，这一部分是可选的，不想折腾的话默认的样式就挺好了，可以不看这里的。</p><p>使用方法就是在徽标图片 URL 后面跟上 <code>?{参数名}={参数值}</code></p><p>多个参数联用的话就是 <code>?{参数名1}={参数值1}&amp;{参数名2}={参数值2}...</code></p><h3 id="1-style"><a href="#1-style" class="headerlink" title="1. style"></a>1. style</h3><p>style 控制徽标的主体样式，有四种，不设置的话默认是 <code>flat</code> 的，示例代码和效果如下：</p><h4 id="plastic"><a href="#plastic" class="headerlink" title="plastic"></a>plastic</h4><p>塑料？大概是指立体效果</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic" alt=""></p><h4 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h4><p>正常的样子，扁平化</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat" alt=""></p><h4 id="flat-square"><a href="#flat-square" class="headerlink" title="flat-square"></a>flat-square</h4><p>扁平化 + 去除圆角</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square" alt=""></p><h4 id="social"><a href="#social" class="headerlink" title="social"></a>social</h4><p>社交样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=social)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?style=social" alt=""></p><h3 id="2-label"><a href="#2-label" class="headerlink" title="2. label"></a>2. label</h3><p>该参数可以用来强制覆盖原有的徽标标题文字，效果如下，原有的 pod 字样已经被覆盖了：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses" alt=""></p><h3 id="3-logo"><a href="#3-logo" class="headerlink" title="3. logo"></a>3. logo</h3><p>该参数可以用来为徽标添加 logo，logo 图片会出现在左半部分的徽标标题左边，logo 图片高度必须 ≥ 14px，logo 图片需要先转为 base64 编码然后直接插入到 URL 中（可以用 <a href="http://b64.io/" target="_blank" rel="noopener">http://b64.io/</a> 将图片转为 base64 编码的字符串），格式如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?logo=&#123;base64 编码后的图片数据&#125;</span><br></pre></td></tr></table></figure><p>示例代码和效果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII" alt=""></p><h3 id="4-logoWidth"><a href="#4-logoWidth" class="headerlink" title="4. logoWidth"></a>4. logoWidth</h3><p>该参数可以设置在上一个参数 logo 中添加的图标的宽度，设为 0 的话即为忽略该参数，示例代码和效果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&amp;logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII" alt=""></p><h3 id="5-link"><a href="#5-link" class="headerlink" title="5. link"></a>5. link</h3><p>据说该参数是用来设置 style 为 social 类型点击后跳转的 URL 的（嗯，俗称超链接），并且应该能够设置左右两边为不同的 URL，官方描述如下：</p><ul><li>Specify what clicking on the left/right of a badge should do (esp. for social badge style)</li></ul><p>如果把 URL 贴到浏览器中直接访问的确是这样的，比如直接在浏览器中打开下面这个链接，点击左半部分会跳到百度，右半部分则跳到 Google（感谢 <a href="https://github.com/yuzhouwww" target="_blank" rel="noopener">@yuzhouwww</a> 同学的提示）：</p><p><a href="https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&amp;link=https://www.baidu.com&amp;link=https://www.google.com" target="_blank" rel="noopener">https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&amp;link=https://www.baidu.com&amp;link=https://www.google.com</a></p><p>不过如果直接添加在 Markdown 中显示貌似没啥效果？如果有大佬知道的求指点，感谢！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&amp;link=https://www.baidu.com&amp;link=https://www.google.com)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&amp;link=https://www.baidu.com&amp;link=https://www.google.com" alt=""></p><h3 id="6-colorA"><a href="#6-colorA" class="headerlink" title="6. colorA"></a>6. colorA</h3><p>该参数用来控制徽标左半部分的背景色，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将左半部分的背景色改为 0xabcdef，代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef" alt=""></p><h3 id="7-colorB"><a href="#7-colorB" class="headerlink" title="7. colorB"></a>7. colorB</h3><p>该参数用来控制徽标右半部分的背景色，同上，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将右半部分的背景色改为 0xabcdef，代码和效果如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef)</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef" alt=""></p><h3 id="8-maxAge"><a href="#8-maxAge" class="headerlink" title="8. maxAge"></a>8. maxAge</h3><p>该参数用来设置 HTTP 缓存时间，以秒为单位，直接在 svg 地址后跟 <code>?maxAge={缓存秒数}</code> 即可，好像没啥好预览的，不放效果图了。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>这里需要注意的是，如果你是引用的第三方 svg 然后添加自己的样式，如果该样式之前已经被第三方添加过，是不一定会覆盖第三方的设置的，也就是说自己设置的属性不一定会生效…例如下面的代码设置 colorB 就没生效：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000)</span><br></pre></td></tr></table></figure><p>右半部分应该变成黑色，但是毫无效果的说：</p><p><img src="https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000" alt=""></p><h1 id="四-其他"><a href="#四-其他" class="headerlink" title="四. 其他"></a>四. 其他</h1><p>默认的徽标是居左排列的，如果需要居中排列需要使用 HTML 的方式来插入徽标，可参考 <a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a>，代码和效果如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://travis-ci.org/onevcat/Kingfisher"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/travis/onevcat/Kingfisher/master.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/Carthage/Carthage/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://swift.org/package-manager/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/badge/SPM-ready-orange.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://onevcat.github.io/Kingfisher/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://onevcat.github.io/Kingfisher/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://codebeat.co/projects/github-com-onevcat-kingfisher"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">"codebeat badge"</span> <span class="attr">src</span>=<span class="string">"https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p align="center"><br><a href="https://travis-ci.org/onevcat/Kingfisher" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/onevcat/Kingfisher/master.svg"></a><br><a href="https://github.com/Carthage/Carthage/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat"></a><br><a href="https://swift.org/package-manager/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SPM-ready-orange.svg"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat"></a><br><a href="https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat"></a><br><a href="http://onevcat.github.io/Kingfisher/" target="_blank" rel="noopener"><img src="https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat"></a><br><a href="https://codebeat.co/projects/github-com-onevcat-kingfisher" target="_blank" rel="noopener"><img alt="codebeat badge" src="https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg"></a><br></p><p>没了，🙄</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/05/01/2017-05-01-GitHub-Badge-Introduction/">http://www.eyrefree.org/2017/05/01/2017-05-01-GitHub-Badge-Introduction/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。&lt;/p&gt;
&lt;p&gt;自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介
      
    
    </summary>
    
      <category term="GitHub" scheme="http://www.eyrefree.org/categories/GitHub/"/>
    
    
      <category term="Badge" scheme="http://www.eyrefree.org/tags/Badge/"/>
    
  </entry>
  
  <entry>
    <title>iOS 在 App 中使用自定义字体</title>
    <link href="http://www.eyrefree.org/UIFontTTF/"/>
    <id>http://www.eyrefree.org/UIFontTTF/</id>
    <published>2017-03-23T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.985Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个神奇的 App 需要添加楷体，检查了一下发现 iOS 默认并不会安装这种字体，需要我们自己将字体文件添加到 App 中，本文主要记录了添加自定义字体的过程、添加完成后的效果以及遇到的一些坑，文中 iOS 代码主要为 Swift 3。</p><hr><h1 id="1-查看全部可用字体"><a href="#1-查看全部可用字体" class="headerlink" title="1. 查看全部可用字体"></a>1. 查看全部可用字体</h1><p>在进行操作之前，我们先查看默认情况下，系统的可用字体有哪些，利用如下代码可以将系统全部字体的 FontFamilyName 以及它们的 FontName 进行打印：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> fontFamily <span class="keyword">in</span> <span class="type">UIFont</span>.familyNames &#123;</span><br><span class="line">    <span class="built_in">print</span>(fontFamily)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> font <span class="keyword">in</span> <span class="type">UIFont</span>.fontNames(forFamilyName: fontFamily) &#123;</span><br><span class="line">        <span class="built_in">print</span>(fontFamily + <span class="string">": "</span> + font)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在日志输出窗口搜索我们需要的楷体，可以看到默认并没有安装，效果如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7350c33cc8513393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看全部可用字体"></p><h1 id="2-获取字体文件"><a href="#2-获取字体文件" class="headerlink" title="2. 获取字体文件"></a>2. 获取字体文件</h1><p>首先，我们需要获取字体文件，一般文件类型为 ttf 或 ttc 的就是字体文件了，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-8128dda0b2489f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体文件"></p><p>可以在 <a href="http://www.zitikoudai.com/" target="_blank" rel="noopener">字体口袋</a>，<a href="http://www.sozi.cn/" target="_blank" rel="noopener">搜字网</a> 之类的网站找到很多可供下载的资源：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-510dc0d1628c7b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体口袋"></p><p>或者也可以在 OS X 的系统字体册找到我们想要的字体，可以从应用程序列表中打开字体册：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-ec156aacb9194153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体册"></p><p>选择 <code>所有字体</code> 然后在搜索栏内键入需要查找的字体名即可列出匹配的项目：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-29901f9b4632925f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在字体册中查找字体"></p><p>右键点击想要的字体选择 <code>在 Finder 中显示</code> 即可找到对应的字体文件。</p><h1 id="3-添加字体文件到工程"><a href="#3-添加字体文件到工程" class="headerlink" title="3. 添加字体文件到工程"></a>3. 添加字体文件到工程</h1><p>将我们获取的字体文件直接拖到工程中的合适位置，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2aad3e8abae38ee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加字体文件"></p><p>添加完成后选中对应的字体文件可进行预览：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-5f5b457a8bdda98b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="预览"></p><p>我们还需要在 <code>Info.plist</code> 文件中添加 Fonts provided by application 项，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-be03386c8a892c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Info.plist 添加 Fonts provided by application 项"></p><p>也可通过直接添加代码的方式完成，例如这里添加两个字体文件 STKaiti.ttf 和 Kaiti-SC.ttf 的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIAppFonts&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;STKaiti.ttf&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;Kaiti-SC.ttf&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure><p>这时，我们对工程进行编译，再次查看可用的全部字体，这时我们可以看到，我们需要的楷体已经添加了进来：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-35090eacafa8f523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功添加楷体"></p><h1 id="4-字体的使用"><a href="#4-字体的使用" class="headerlink" title="4. 字体的使用"></a>4. 字体的使用</h1><h2 id="1-StoryBoard"><a href="#1-StoryBoard" class="headerlink" title="1. StoryBoard"></a>1. StoryBoard</h2><p>在 StoryBoard 中使用的话，只需要设置控件的 Font 属性为，选择 Custom，然后再从 Family 中选择需要的字体即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-ae1d2f52ed178db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在 StoryBoard 中使用"></p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>我们直接通过如下代码直接生成一个楷体的字体对象，将其赋给 UIButton 或者 UILabel 等空间对应的属性即可。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIFont</span>(name: <span class="string">"STKaiti"</span>, size: <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意的是 UIFont 的 name 字符串必须是上面我们打印出的字体名称，和字体文件的文件名或者其他信息无关。如果这里我们输入了一个无效的字体名称，可能会返回一个空的对象，所以我的使用方式如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIFont</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">boldKaiti</span><span class="params">(ofSize fontSize: CGFloat)</span></span> -&gt; <span class="type">UIFont</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIFont</span>(name: <span class="string">"Kaiti SC Black"</span>, size: fontSize) ?? <span class="type">UIFont</span>.systemFont(ofSize: fontSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">kaiti</span><span class="params">(ofSize fontSize: CGFloat)</span></span> -&gt; <span class="type">UIFont</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIFont</span>(name: <span class="string">"Kaiti SC"</span>, size: fontSize) ?? <span class="type">UIFont</span>.systemFont(ofSize: fontSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用楷体前后效果对比，可以看到换个字体以后感觉整个 feel 就不一样了，可见我们要好好听设计师蜀黍们的话，该用啥字体用啥字体，不能偷懒，😂 （嘛，控件位置还没调整，第二段可能有点放不下了）：</p><table><thead><tr><th style="text-align:center">添加字体前</th><th style="text-align:center">添加字体后</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-af181721cca8c174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-e089745639153fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td></tr></tbody></table><h1 id="5-一些坑"><a href="#5-一些坑" class="headerlink" title="5. 一些坑"></a>5. 一些坑</h1><h4 id="1-字体文件过大"><a href="#1-字体文件过大" class="headerlink" title="1. 字体文件过大"></a>1. 字体文件过大</h4><p>如果你用的字体文件是 TTC 格式的，可以考虑去下载单独的 TTF 字体文件，TTC 是几个 TTF 合成的字库，里面包含不止一种字体类型。</p><p>然后多个类似的字体，可以和设计师商量一下统一使用同一种字体。</p><p>唔，如果是单个 TTF 文件过大的话，暂时木有找到好的解决办法，可以考虑多下几个不同来源的同种字体的文件，挑一个体积最小的。或者对现有的 TTF 文件进行编辑，将一些低频字符进行删除。</p><h4 id="2-字体重名问题"><a href="#2-字体重名问题" class="headerlink" title="2. 字体重名问题"></a>2. 字体重名问题</h4><p>在导入同一种字体的不同风格时，比如这里楷体的粗体 <code>Kaiti-SC-Black</code> 和普通体 <code>Kaiti-SC-Regular</code> ，在 App 中打印出的 FontName 居然只有一个楷体的，这是为啥呢，推测可能是字体文件生成的时候填写字体名偷工减料，没有填写完整的字体名或者字体名识别异常导致的。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-cd76f9fd80856fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只有一个楷体"></p><p>然后我找了一个 OS X 下可用的免费字体编辑工具 BirdFont 对字体文件进行查看想一探究竟，官网地址 <a href="https://birdfont.org/" target="_blank" rel="noopener">https://birdfont.org/</a>，我用的是 <a href="http://eyrefree.coding.me/FileKeeper/birdfont-2.15.5-free.dmg" target="_blank" rel="noopener">2.15.5</a> 版本，大家可以自行去官网下载最新版。</p><p>在 Finder 中打开我们的字体文件，右键选择用 BirdFont 进行打开即可，因为字体文件数据量较大，打开过程可能会有些长，需要耐心等待几分钟，具体时长根据数据量而定，等软件右上角的 Loading 消失即表示打开完成。</p><p>点击右上角菜单，选择 Name and Description 选项可打开字体描述信息编辑页面：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f0a8629b4d2b6382.png" alt="Name and Description"></p><p>在这里我们可以看到，Kaiti-SC-Black 和 Kaiti-SC-Regular 两个字体文件的 <code>Name</code> 一栏确实是只写了 Kaiti SC，和我们之前在 App 中输出的字体名称一致，<code>Style</code> 一栏虽然有所区别，但是我们在 App 中是无法通过 <code>Style</code> 这个参数来找到某个字体的（反正我没找到，如果真的有办法希望可以教我，蟹蟹，😂 ），所以这应该就是我们只能在 App 中找到一个楷体的原因了。</p><table><thead><tr><th style="text-align:center">BirdFont Kaiti-SC-Black</th><th style="text-align:center">BirdFont Kaiti-SC-Regular</th><th style="text-align:center">App</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-36d14efc746d886a.png" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-c828d1f366a82258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td><td style="text-align:center"><img src="http://upload-images.jianshu.io/upload_images/1018190-4b11a9f1122e702b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td></tr></tbody></table><p>然后我们对其中一个字体的 <code>Name</code> 做一下修改，反正使俩字体文件的 Name 不一样就行，然后我这里将 Kaiti-SC-Black 的 <code>Name</code> 改为 Kaiti SC Black，改完之后需要先 Save，然后选择 Import and Export：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-c27be693b5abdae5.png" alt="Import and Export"></p><p>然后再选择 Export Fonts：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-0d4f161f80baa28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Export Fonts"></p><p>然后会弹出 Export Settings 页面进行一些参数设置，注意将 Formats 中的 TTF 选项勾选即可，其他的两个选项可以去掉，加快导出速度。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2a2a4271cfbc9133.png" alt="Export Settings"></p><p>然后单击下面的 Export 按钮即可开始导出工作，右上角会出现一个 Loading 视图，等它消失就表示导出完成了，导出完成后会在 Finder 中打开对应字体文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-06962a1c5acf94a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导出完成"></p><p>我们将其添加到工程中再看下能不能找到它：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-96d28c83f011ed0c.png" alt="新增 Kaiti SC Black 字体"></p><p>可以看到这一次多了一个名为 Kaiti SC Black 的字体，完成！</p><p>PS：</p><p>最后吐槽一下，BirdFont 这工具真的好慢，巨慢，慢到爆炸，🙄 。大家在操作过过程中尽量挑体积小一点的字体文件进行操作。不过还好，使用过程中还没遇到闪退之类的状况，功能上没问题。希望后续版本能够提高处理速度。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/03/23/2017-03-23-UIFont-TTF/">http://www.eyrefree.org/2017/03/23/2017-03-23-UIFont-TTF/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做一个神奇的 App 需要添加楷体，检查了一下发现 iOS 默认并不会安装这种字体，需要我们自己将字体文件添加到 App 中，本文主要记录了添加自定义字体的过程、添加完成后的效果以及遇到的一些坑，文中 iOS 代码主要为 Swift 3。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="TTF" scheme="http://www.eyrefree.org/tags/TTF/"/>
    
  </entry>
  
  <entry>
    <title>利用 Travis-CI 让你在 GitHub 上的 CocoaPods 库持续构建</title>
    <link href="http://www.eyrefree.org/TravisCI/"/>
    <id>http://www.eyrefree.org/TravisCI/</id>
    <published>2017-03-16T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.985Z</updated>
    
    <content type="html"><![CDATA[<p>Travis-CI 是一个专门为开源项目打造的持续集成环境，目前已经支持绝大部分主流语言，它采用 yaml 格式，简洁清新独树一帜（感谢百度百科，2333）。</p><p>每次 Commit 后会执行构建操作，并在 GitHub 对应的 Commit 后显示构建状态或结果，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-87b43c1d2d1e9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持续构建效果预览"></p><p>本文以 <a href="https://github.com/EyreFree/EFQRCode" target="_blank" rel="noopener">EFQRCode</a>(一个使用 Swift 作为开发语言的 CocoaPods 开源库) 为例，简述怎样为自己的开源项目添加持续构建功能。</p><h1 id="1-指定-Swift-版本"><a href="#1-指定-Swift-版本" class="headerlink" title="1. 指定 Swift 版本"></a>1. 指定 Swift 版本</h1><p>在根目录下添加一个 .swift-version 文件，在其中填写 Swift 版本号，例如这里 EFQRCode 库使用 Swift 3.0 进行开发，所以这里填写的是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h1 id="2-添加-Travis-CI-配置文件"><a href="#2-添加-Travis-CI-配置文件" class="headerlink" title="2. 添加 Travis-CI 配置文件"></a>2. 添加 Travis-CI 配置文件</h1><p>在根目录下添加一个 .travis.yml 文件，在其中填写配置信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">osx_image: xcode8</span><br><span class="line">language: objective-c</span><br><span class="line"></span><br><span class="line">cache: cocoapods</span><br><span class="line">podfile: Example/Podfile</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - LANG=en_US.UTF-8</span><br><span class="line">    - LC_ALL=en_US.UTF-8</span><br><span class="line">    - XCODE_WORKSPACE=Example/EFQRCode.xcworkspace</span><br><span class="line">  matrix:</span><br><span class="line">    - SCHEME=&quot;EFQRCode-Example&quot;</span><br><span class="line"></span><br><span class="line">before_install:</span><br><span class="line">  - gem install xcpretty --no-rdoc --no-ri --no-document --quiet</span><br><span class="line">  - gem install cocoapods --pre --no-rdoc --no-ri --no-document --quiet</span><br><span class="line">  - pod install --project-directory=Example</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">  - set -o pipefail</span><br><span class="line">  - xcodebuild -workspace &quot;$XCODE_WORKSPACE&quot; -scheme &quot;$SCHEME&quot; -configuration Debug clean build CODE_SIGN_IDENTITY=&quot;&quot; CODE_SIGNING_REQUIRED=NO | xcpretty -c</span><br><span class="line">  - xcodebuild -workspace &quot;$XCODE_WORKSPACE&quot; -scheme &quot;$SCHEME&quot; -configuration Release clean build CODE_SIGN_IDENTITY=&quot;&quot; CODE_SIGNING_REQUIRED=NO | xcpretty -c</span><br><span class="line">  - pod lib lint --no-clean</span><br><span class="line"></span><br><span class="line">after_success:</span><br><span class="line">  - sleep 5</span><br></pre></td></tr></table></figure><h1 id="3-注册-Travis-CI-账号"><a href="#3-注册-Travis-CI-账号" class="headerlink" title="3. 注册 Travis-CI 账号"></a>3. 注册 Travis-CI 账号</h1><p>打开 <a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> 注册一个 Travis-CI 账号，也可以通过 GitHub 账户直接登陆。Travis-CI 服务对开源项目是免费的，所以你的私有项目无法享受到免费的持续构建服务。</p><h1 id="4-从-GitHub-同步项目"><a href="#4-从-GitHub-同步项目" class="headerlink" title="4. 从 GitHub 同步项目"></a>4. 从 GitHub 同步项目</h1><p>第一次进入时会自动从 GitHub 同步项目数据，可能需要等待一段的时间进行同步，同步完成后可以看到如下的项目列表：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d01facdae4cb29f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目列表"></p><p>一般情况下每隔一定的时间 Travis-CI 都会从 GitHub 自动同步数据，如果新添加的项目想要立刻同步到 Travis-CI 的话，可以手动点击右上角的 Sync account 同步按钮，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d14d4450f3790330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步按钮"></p><h1 id="5-开启持续集成"><a href="#5-开启持续集成" class="headerlink" title="5. 开启持续集成"></a>5. 开启持续集成</h1><p>然后接下来就是开启对应项目的持续构建，大家应该已经猜到该怎么做了吧…将对应项目之前的 Switch 按钮设为启用绿色勾选状态即可，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2085dfac1d55e776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="勾选状态"></p><h1 id="6-观察错误日志"><a href="#6-观察错误日志" class="headerlink" title="6. 观察错误日志"></a>6. 观察错误日志</h1><p>若发生构建失败，可通过查看错误日志的方式来定位具体问题原因，可点击工程名，选择出错的那一次构建即可：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a483be7d32c674bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建日志"></p><h1 id="7-一些废话"><a href="#7-一些废话" class="headerlink" title="7. 一些废话"></a>7. 一些废话</h1><p>本文只提供了针对 Swift CocoaPods 库的操作步骤，Travis-CI 具体到每种语言／项目的构建配置各不相同，参数各异，有的时候还需要根据自己的项目特性做一些个性化的调整，需要我们多思考，多调试，多尝试，总之不要轻易放弃哇。别问我是怎么知道的，😂 ：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7cbf867d9314dbbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="坑"></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/03/16/2017-03-16-Travis-CI/">http://www.eyrefree.org/2017/03/16/2017-03-16-Travis-CI/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Travis-CI 是一个专门为开源项目打造的持续集成环境，目前已经支持绝大部分主流语言，它采用 yaml 格式，简洁清新独树一帜（感谢百度百科，2333）。&lt;/p&gt;
&lt;p&gt;每次 Commit 后会执行构建操作，并在 GitHub 对应的 Commit 后显示构建状态或结果
      
    
    </summary>
    
      <category term="GitHub" scheme="http://www.eyrefree.org/categories/GitHub/"/>
    
    
      <category term="Travis-CI" scheme="http://www.eyrefree.org/tags/Travis-CI/"/>
    
  </entry>
  
  <entry>
    <title>iOS 利用 NEHotspotHelper 获取 WiFi 列表</title>
    <link href="http://www.eyrefree.org/HotspotHelper/"/>
    <id>http://www.eyrefree.org/HotspotHelper/</id>
    <published>2017-03-09T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.984Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 9 发布之后，苹果推出了 NetworkExtension，利用这个框架可以实现很多和网络相关的操作。本文主要介绍怎样使用其中的 NEHotspotHelper 进行设备 WiFi 列表的获取。</p><p>Demo 地址：<a href="https://github.com/EyreFree/EFNEHotspotHelperDemo" target="_blank" rel="noopener">https://github.com/EyreFree/EFNEHotspotHelperDemo</a></p><h1 id="一-注意事项"><a href="#一-注意事项" class="headerlink" title="一. 注意事项"></a>一. 注意事项</h1><ol><li>首先，NEHotspotHelper 只在 iOS 9 及以上版本得到支持，之前版本的 iOS 并不支持该功能；</li><li>然后，你需要有一个开发者账号；</li><li>最后，该框架目前还没有大规模开放使用，所以需要向苹果发送申请并且审核通过才能够获得使用该框架的权限，大致内容就是描述一下你需要使用该框架的原因之类的，然后我是用的英文进行描述（感谢百度以及谷歌翻译），不过据说中文也行。提交申请后大概一周内会收到反馈邮件，申请地址为： <a href="https://developer.apple.com/contact/network-extension/" target="_blank" rel="noopener">https://developer.apple.com/contact/network-extension/</a> 。</li></ol><h1 id="二-创建-App-ID"><a href="#二-创建-App-ID" class="headerlink" title="二. 创建 App ID"></a>二. 创建 App ID</h1><p>打开苹果开发者中心，登陆然后找到 App IDs 选项，点击右上角按钮创建一个 App ID 用于接下来创建 Provisioning Profile，地址为： <a href="https://developer.apple.com/account/ios/identifier/bundle/" target="_blank" rel="noopener">https://developer.apple.com/account/ios/identifier/bundle/</a>  ，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-f447bfbbb6095d33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 App ID"></p><p>首先，填写 Name 以及 Bundle ID，这里统一填写为 EFNEHotspotHelperDemo，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-1fda13b55d6683a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填写 Name"></p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a51c01c1bb8e0ef9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填写 Bundle ID"></p><p>接下来这一步注意需要勾选 Wireless Accessory Configuration 这一选项，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-5acb269c05aacea5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="勾选 Wireless Accessory Configuration"></p><p>然后观察到如图所示状态表明已成功打开：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-73d2e00e40181d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态显示"></p><p>在 App IDs 列表中查看刚创建完成的 App ID：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2d0024f561ed17ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="App IDs 列表"></p><h1 id="三-创建-Provisioning-Profile"><a href="#三-创建-Provisioning-Profile" class="headerlink" title="三. 创建 Provisioning Profile"></a>三. 创建 Provisioning Profile</h1><p>找到 Provisioning Profiles 选项，点击右上角按钮创建一个 Provisioning Profile 用于接下来创建示例工程，地址为： <a href="https://developer.apple.com/account/ios/profile/" target="_blank" rel="noopener">https://developer.apple.com/account/ios/profile/</a>  ，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-911e7761ba3c44e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建 Provisioning Profile"></p><p>首先选择 Profile 类型，这里我选择的是 iOS App Development，可以根据自己的具体需要自由选择：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-d5061ad530a3f724.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 Profile 类型"></p><p>接下来选择我们在第二步创建好的 App ID，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-4e017ec4c1c09402.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 App ID"></p><p>然后选择证书和设备，全选即可：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-9c675e9238d1da11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择证书"></p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-58a130484fdfed6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择设备"></p><p>在额外权限这一步需要选中我们申请到的 Network Extension 权限，可以看到其中包含我们需要使用的 NEHotspotHelper 权限，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a6abfce07b76a017.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选中 Network Extension 权限"></p><p>填写完 Profile Name 之后，即可成功创建我们需要的 Profile：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-2f602ebf05102c28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填写 Profile Name"></p><p>点击 Download 将它下载到本地：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-1bf8b38560227b93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载 Profile"></p><p>双击打开，即可将 Profile 添加到本机：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-42e294701187033a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加 Profile"></p><p>可以到 XCode 的账户设置里查看已安装的 Profile，若未安装成功可以尝试点击 Action 中的 Download 按钮重新下载：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-99fff3c8f41706d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看已安装的 Profile"></p><h1 id="四-创建工程"><a href="#四-创建工程" class="headerlink" title="四. 创建工程"></a>四. 创建工程</h1><p>接下来我们创建一个示例工程，演示如何获取 WiFi 列表。首先，将 Bundle ID 改为之前设置的 EFNEHotspotHelperDemo：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-a39aced31600687a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改 Bundle ID"></p><p>然后在 Info.plist 中添加后台模式权限数组：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-1870d94c708379d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加后台模式代码"></p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>UIBackgroundModes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>network-authentication<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完成后可以在 Target -&gt; Capabilities 中看到后台模式已处于开启状态：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-99c24463ac8fa56f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台模式已开启"></p><p>接下来在 Capabilities 找到 Wireless Accessory Configuration 并将其打开：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-8eb012d9732a3197.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开 Wireless Accessory Configuration"></p><p> 在工程中找到后缀为 {工程名}.entitlements 的文件 EFNEHotspotHelperDemo.entitlements，在其中加入 HotspotHelper 权限代码：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-065ba9d93185a539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加 HotspotHelper 权限代码"></p><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.networking.HotspotHelper<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>好了，到这里已经完成了各种乱七八糟的配置工作，可以尝试进行 Build。如果没有提示错误信息的话，接下来就可以愉快地使用 HotspotHelper 了；如果有问题的话，请检查之前的步骤是否都已正确完成或者根据错误信息修改具体项目。</p><h1 id="五-核心代码"><a href="#五-核心代码" class="headerlink" title="五. 核心代码"></a>五. 核心代码</h1><p>首先，在需要使用 HotspotHelper 的地方添加头文件引用，这里以 Objective-C 代码为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;NetworkExtension/NetworkExtension.h&gt;</span><br></pre></td></tr></table></figure><p>然后使用如下代码即可将 WiFi 列表信息打印到 XCode 控制台，注意：这里需要打开系统 <code>设置</code> 中的 <code>无线局域网</code> 页面才可以触发回调：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)scanWifiInfos&#123;</span><br><span class="line">    NSLog(@&quot;1.Start&quot;);</span><br><span class="line"></span><br><span class="line">    NSMutableDictionary* options = [[NSMutableDictionary alloc] init];</span><br><span class="line">    [options setObject:@&quot;EFNEHotspotHelperDemo&quot; forKey: kNEHotspotHelperOptionDisplayName];</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;EFNEHotspotHelperDemo&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;2.Try&quot;);</span><br><span class="line">    BOOL returnType = [NEHotspotHelper registerWithOptions: options queue: queue handler: ^(NEHotspotHelperCommand * cmd) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;4.Finish&quot;);</span><br><span class="line">        NEHotspotNetwork* network;</span><br><span class="line">        if (cmd.commandType == kNEHotspotHelperCommandTypeEvaluate || cmd.commandType == kNEHotspotHelperCommandTypeFilterScanList) &#123;</span><br><span class="line">            // 遍历 WiFi 列表，打印基本信息</span><br><span class="line">            for (network in cmd.networkList) &#123;</span><br><span class="line">                NSString* wifiInfoString = [[NSString alloc] initWithFormat: @&quot;---------------------------\nSSID: %@\nMac地址: %@\n信号强度: %f\nCommandType:%ld\n---------------------------\n\n&quot;, network.SSID, network.BSSID, network.signalStrength, (long)cmd.commandType];</span><br><span class="line">                NSLog(@&quot;%@&quot;, wifiInfoString);</span><br><span class="line"></span><br><span class="line">                // 检测到指定 WiFi 可设定密码直接连接</span><br><span class="line">                if ([network.SSID isEqualToString: @&quot;测试 WiFi&quot;]) &#123;</span><br><span class="line">                    [network setConfidence: kNEHotspotHelperConfidenceHigh];</span><br><span class="line">                    [network setPassword: @&quot;123456789&quot;];</span><br><span class="line">                    NEHotspotHelperResponse *response = [cmd createResponse: kNEHotspotHelperResultSuccess];</span><br><span class="line">                    NSLog(@&quot;Response CMD: %@&quot;, response);</span><br><span class="line">                    [response setNetworkList: @[network]];</span><br><span class="line">                    [response setNetwork: network];</span><br><span class="line">                    [response deliver];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 注册成功 returnType 会返回一个 Yes 值，否则 No</span><br><span class="line">    NSLog(@&quot;3.Result: %@&quot;, returnType == YES ? @&quot;Yes&quot; : @&quot;No&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-演示"><a href="#六-演示" class="headerlink" title="六. 演示"></a>六. 演示</h1><p>唔，Demo 运行效果如下，点击 <code>Open WiFi Setting</code> 按钮可直接打开 <code>无线局域网</code> 页面：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-761d24d00368fc0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行效果"></p><p>具体可尝试下载 Demo 并完成相应配置后体验：<a href="https://github.com/EyreFree/EFNEHotspotHelperDemo" target="_blank" rel="noopener">https://github.com/EyreFree/EFNEHotspotHelperDemo</a></p><h1 id="七-备注"><a href="#七-备注" class="headerlink" title="七. 备注"></a>七. 备注</h1><p>参考以下资料完成本 Demo，在此表示感谢：</p><p><a href="http://blog.csdn.net/i374711088/article/details/51655526" target="_blank" rel="noopener">IOS NetworkExtension 框架使用笔记</a><br><a href="http://blog.csdn.net/toto18369905359/article/details/52622115" target="_blank" rel="noopener">iOS NEHotspotHelper使用</a><br><a href="https://github.com/42vio/iOS-NetworkExtension-NEHotspotHelper" target="_blank" rel="noopener">iOS-NetworkExtension-NEHotspotHelper</a><br><a href="https://developer.apple.com/reference/networkextension" target="_blank" rel="noopener">API Reference - NetworkExtension</a></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/03/09/2017-03-09-NEHotspotHelper/">http://www.eyrefree.org/2017/03/09/2017-03-09-NEHotspotHelper/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS 9 发布之后，苹果推出了 NetworkExtension，利用这个框架可以实现很多和网络相关的操作。本文主要介绍怎样使用其中的 NEHotspotHelper 进行设备 WiFi 列表的获取。&lt;/p&gt;
&lt;p&gt;Demo 地址：&lt;a href=&quot;https://git
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="NEHotspotHelper" scheme="http://www.eyrefree.org/tags/NEHotspotHelper/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3 编写的图片分享应用</title>
    <link href="http://www.eyrefree.org/VSCAM/"/>
    <id>http://www.eyrefree.org/VSCAM/</id>
    <published>2017-02-05T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.984Z</updated>
    
    <content type="html"><![CDATA[<p>VSCAM 是一款图片分享应用，此处为使用 Swift 编写的 iOS 版本。</p><p>项目地址：<a href="https://github.com/EyreFree/VSCAM" target="_blank" rel="noopener">https://github.com/EyreFree/VSCAM</a></p><hr><p>首页使用 UICollectionView 实现不同尺寸图片的瀑布流展示；<br>发布页使用 Alamofire 实现了图片后台上传并且实时显示上传进度；<br>图片详情页使用 UITableView 实现了类似 QQ 个人信息页面的背景图片拉伸效果；<br>利用 MJPhotoBrowser 实现图片浏览功能；<br>登录与注册页使用 UITableView 实现了焦点所在编辑框自动滚动到屏幕中心的效果；<br>使用 ShareExtension 利用系统分享实现从浏览器页面打开 App 对应页面；<br>使用 3D Touch 实现从剪贴板读取 URL 快速打开 App 内指定页面；<br>完成国际化，添加英文支持；<br>集成 UMeng 与 Fabric 统计分析 SDK，可作为新手参考。</p><h2 id="AppStore"><a href="#AppStore" class="headerlink" title="AppStore"></a>AppStore</h2><p><a target="_blank" href="https://itunes.apple.com/cn/app/VSCAM/id1163589746?mt=8"><br>    <img src="http://ww2.sinaimg.cn/large/0060lm7Tgw1f1hgrs1ebwj308102q0sp.jpg" width="144" height="49"><br></a></p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>XCode 8.0+</li><li>Swift 3.0+</li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ol><li>首先，需要安装 <a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="noopener">CocoaPods</a> 如果你没有安装的话；</li><li>在终端中移动到当前工程根目录下执行 <code>pod install</code>；</li><li>用 XCode 打开 VSCAM.xcworkspace；</li><li>构建。</li></ol><h2 id="计划中"><a href="#计划中" class="headerlink" title="计划中"></a>计划中</h2><ol><li>iPad 适配；</li><li>动画；</li><li>评论／点赞。</li></ol><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="https://raw.githubusercontent.com/EyreFree/VSCAM/master/assets/screenshot.png" alt=""></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>EyreFree, eyrefree@eyrefree.org</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>VSCAM is available under the MIT license. See the LICENSE file for more info.</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/02/05/2017-02-05-VSCAM/">http://www.eyrefree.org/2017/02/05/2017-02-05-VSCAM/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;VSCAM 是一款图片分享应用，此处为使用 Swift 编写的 iOS 版本。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/EyreFree/VSCAM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gi
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://www.eyrefree.org/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 花式二维码生成和二维码识别</title>
    <link href="http://www.eyrefree.org/EFQRCode/"/>
    <id>http://www.eyrefree.org/EFQRCode/</id>
    <published>2017-01-25T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.984Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 原生的二维码识别非常之棒，反正比 ZXing 和 ZBar 效果都好些，所以以后打算尽量用原生的二维码识别，然后最近把原生的二维码生成也顺便做了一遍，并且在原有基础上加了一些样式参数，封了一个小库方便以后使用。</p><p>项目地址：<a href="https://github.com/EyreFree/EFQRCode" target="_blank" rel="noopener">https://github.com/EyreFree/EFQRCode</a></p><hr><p><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/EFQRCode.jpg" alt=""></p><p>EFQRCode 是一个用 Swift 编写的用来生成和识别二维码的库，它基于系统二维码生成与识别进行开发。</p><ul><li>生成：利用输入的水印图/图标等资源生成各种艺术二维码；</li><li>识别：识别率比 iOS 原生二维码识别率更高。</li></ul><h2 id="一-效果预览"><a href="#一-效果预览" class="headerlink" title="一. 效果预览"></a>一. 效果预览</h2><table><thead><tr><th style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode1.jpg" alt=""></th><th style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode2.jpg" alt=""></th><th style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode3.jpg" alt=""></th><th style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode4.jpg" alt="">  </th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode5.jpg" alt=""></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode6.jpg" alt=""></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode7.jpg" alt=""></td><td style="text-align:center"><img src="https://raw.githubusercontent.com/EyreFree/EFQRCode/master/assets/QRCode8.jpg" alt="">  </td></tr></tbody></table><h2 id="二-示例"><a href="#二-示例" class="headerlink" title="二. 示例"></a>二. 示例</h2><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:EyreFree/EFQRCode.git; <span class="built_in">cd</span> EFQRCode/Example; pod install; open EFQRCode.xcworkspace</span><br></pre></td></tr></table></figure><h2 id="三-环境"><a href="#三-环境" class="headerlink" title="三. 环境"></a>三. 环境</h2><ul><li>XCode 8.0+</li><li>Swift 3.0+</li></ul><h2 id="四-安装"><a href="#四-安装" class="headerlink" title="四. 安装"></a>四. 安装</h2><p>EFQRCode 可以通过 <a href="http://cocoapods.org" target="_blank" rel="noopener">CocoaPods</a> 进行获取。只需要在你的 Podfile 中添加如下代码就能实现引入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &quot;EFQRCode&quot;, &apos;~&gt; 1.2.0&apos;</span><br></pre></td></tr></table></figure><h2 id="五-快速使用"><a href="#五-快速使用" class="headerlink" title="五. 快速使用"></a>五. 快速使用</h2><h4 id="1-导入-EFQRCode"><a href="#1-导入-EFQRCode" class="headerlink" title="1. 导入 EFQRCode"></a>1. 导入 EFQRCode</h4><p>在你需要使用的地方添加如下代码引入 EFQRCode 模块：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> EFQRCode</span><br></pre></td></tr></table></figure><h4 id="2-二维码识别"><a href="#2-二维码识别" class="headerlink" title="2. 二维码识别"></a>2. 二维码识别</h4><p>获取图片中所包含的二维码，同一张图片中可能包含多个二维码，所以返回值是一个字符串数组：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> testImage = <span class="type">UIImage</span>(named: <span class="string">"test.png"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> tryCodes = <span class="type">EFQRCode</span>.recognize(image: testImage) &#123;</span><br><span class="line">        <span class="keyword">if</span> tryCodes.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(tryCodes.<span class="built_in">count</span>)</span> codes in testImage."</span>)</span><br><span class="line">            <span class="keyword">for</span> (index, code) <span class="keyword">in</span> tryCodes.enumerated() &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"The content of <span class="subst">\(index)</span> QR Code is: <span class="subst">\(code)</span>."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"There is no QR Codes in testImage."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Recognize failed, check your input image!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二维码生成"><a href="#3-二维码生成" class="headerlink" title="3. 二维码生成"></a>3. 二维码生成</h4><p>根据所输入参数创建各种艺术二维码图片，快速使用方式如下:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用参数:</span></span><br><span class="line"><span class="comment">//                         content: 二维码内容</span></span><br><span class="line"><span class="comment">// inputCorrectionLevel (Optional): 容错率</span></span><br><span class="line"><span class="comment">//                                  L 7%</span></span><br><span class="line"><span class="comment">//                                  M 15%</span></span><br><span class="line"><span class="comment">//                                  Q 25%</span></span><br><span class="line"><span class="comment">//                                  H 30%(默认值)</span></span><br><span class="line"><span class="comment">//                 size (Optional): 边长</span></span><br><span class="line"><span class="comment">//        magnification (Optional): 放大倍数</span></span><br><span class="line"><span class="comment">//                                  (如果 magnification 不为空，将会忽略 size 参数)</span></span><br><span class="line"><span class="comment">//      backgroundColor (Optional): 背景色</span></span><br><span class="line"><span class="comment">//      foregroundColor (Optional): 前景色</span></span><br><span class="line"><span class="comment">//                 icon (Optional): 中心图标</span></span><br><span class="line"><span class="comment">//             iconSize (Optional): 中心图标边长</span></span><br><span class="line"><span class="comment">//       isIconColorful (Optional): 中心图标是否为彩色</span></span><br><span class="line"><span class="comment">//            watermark (Optional): 水印图</span></span><br><span class="line"><span class="comment">//        watermarkMode (Optional): 水印图模式</span></span><br><span class="line"><span class="comment">//  isWatermarkColorful (Optional): 水印图是否为彩色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外参数</span></span><br><span class="line"><span class="comment">//           foregroundPointOffset: 前景点偏移量</span></span><br><span class="line"><span class="comment">//                allowTransparent: 允许透明</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tryImage = <span class="type">EFQRCode</span>.generate(</span><br><span class="line">    content: <span class="string">"https://github.com/EyreFree/EFQRCode"</span>,</span><br><span class="line">    magnification: <span class="number">9</span>,</span><br><span class="line">    watermark: <span class="type">UIImage</span>(named: <span class="string">"WWF"</span>),</span><br><span class="line">    watermarkMode: .scaleAspectFill,</span><br><span class="line">    isWatermarkColorful: <span class="literal">false</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Create QRCode image success!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Create QRCode image failed!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7579f281bbd2d0fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成示例"></p><h2 id="六-使用指南"><a href="#六-使用指南" class="headerlink" title="六. 使用指南"></a>六. 使用指南</h2><p>详情可参见具体使用文档：<a href="https://github.com/EyreFree/EFQRCode/blob/master/README_CN.md" target="_blank" rel="noopener">https://github.com/EyreFree/EFQRCode/blob/master/README_CN.md</a></p><h2 id="七-备注"><a href="#七-备注" class="headerlink" title="七. 备注"></a>七. 备注</h2><ol><li>请选用对比度较高的前景色和背景色组合；</li><li>想要提高生成二维码的清晰度可以选择使用 <code>magnificatio</code> 替代 <code>size</code>，或适当提高它们的数值；</li><li>放大倍数过高／边长过大／二维码内容过多可能会导致生成失败；</li><li>建议对生成的二维码进行测试后投入使用，例如微信能够扫描成功并不代表支付宝也能成功扫描，请务必根据您的具体业务需要做有针对性的测试；</li><li>若有任何问题，期待得到您的反馈，<code>Issue</code> 和 <code>Pull request</code> 都是受欢迎的。</li></ol><p>备注的备注：好用的话可以给个<code>星星</code>，蟹蟹，QAQ…</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2017/01/25/2017-01-25-EFQRCode/">http://www.eyrefree.org/2017/01/25/2017-01-25-EFQRCode/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS 原生的二维码识别非常之棒，反正比 ZXing 和 ZBar 效果都好些，所以以后打算尽量用原生的二维码识别，然后最近把原生的二维码生成也顺便做了一遍，并且在原有基础上加了一些样式参数，封了一个小库方便以后使用。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="QRCode" scheme="http://www.eyrefree.org/tags/QRCode/"/>
    
  </entry>
  
  <entry>
    <title>十分钟开发一款 iOS 表情包 App</title>
    <link href="http://www.eyrefree.org/CodingEmoji/"/>
    <id>http://www.eyrefree.org/CodingEmoji/</id>
    <published>2016-11-24T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.984Z</updated>
    
    <content type="html"><![CDATA[<p>在最近更新的 iOS 10 系统中，苹果开放了 iMessage Stickers 的开发，通俗的说法就是我们现在可以为 iMessage 开发表情包了。<br>表情包的开发十分简单，不需要写一行代码，只需要准备好图片资源即可。本文主要以 Coding 的<a href="https://coding.net/u/coding/p/Onion-Monkey-Emoji/git" target="_blank" rel="noopener">洋葱猴系列表情</a>为例快速开发一款表情包 App。</p><p>本文所需所有素材以及工程文件地址：<br><a href="https://github.com/EyreFree/CodingEmoji" target="_blank" rel="noopener">https://github.com/EyreFree/CodingEmoji</a></p><hr><h1 id="一-注意事项"><a href="#一-注意事项" class="headerlink" title="一.注意事项"></a>一.注意事项</h1><p>开发环境：XCode 8.0 及以上；<br>运行环境：iOS 10 及以上；<br>其他：表情包图片的格式可以是 JPG, PNG, GIF 等，不过单张图片最大不能超过 500KB。</p><h1 id="二-准备图片"><a href="#二-准备图片" class="headerlink" title="二.准备图片"></a>二.准备图片</h1><p>下载洋葱猴表情包，找到其中的表情图片。<br>（下载地址：<a href="https://coding.net/u/coding/p/Onion-Monkey-Emoji/git）" target="_blank" rel="noopener">https://coding.net/u/coding/p/Onion-Monkey-Emoji/git）</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-5bcefc958791bbeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="洋葱猴表情包"></p><h1 id="三-建立工程"><a href="#三-建立工程" class="headerlink" title="三.建立工程"></a>三.建立工程</h1><h2 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1.新建工程"></a>1.新建工程</h2><p>打开 XCode，新建 Sticker Pack Application 工程，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-0b7408065e8b9efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建 Sticker Pack Application 工程"></p><h2 id="2-添加图标"><a href="#2-添加图标" class="headerlink" title="2.添加图标"></a>2.添加图标</h2><p>Sticker Pack Application 的图标和一般的 iOS 应用不太一样，它部分图标是扁的，详细尺寸如下（最后一个为 App Store 需要上传的图标尺寸。其他为工程内用到的应用图标）：</p><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">Size</th><th style="text-align:center">PS</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">54 x 40</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">58 x 58</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">64 x 48</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">81 x 60</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">87 x 87</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">96 x 72</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">120 x 90</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">134 x 100</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">148 x 110</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">180 x 135</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">1024 x 768</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">1024 x 1024</td><td style="text-align:center">App Store 应用图标</td></tr></tbody></table><p><img src="http://upload-images.jianshu.io/upload_images/1018190-7a4a2618c8a958f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用图标"></p><h2 id="3-导入表情图片"><a href="#3-导入表情图片" class="headerlink" title="3.导入表情图片"></a>3.导入表情图片</h2><p>接下来，可以将我们想要添加到表情包里的图片拖到 Sticker Pack 目录中，如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-dde7f28f09c1cf87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入表情图片"></p><h2 id="4-修改表情包名称"><a href="#4-修改表情包名称" class="headerlink" title="4.修改表情包名称"></a>4.修改表情包名称</h2><p>我们可以通过修改 Display Name 的方式来修改表情包在设备上显示的名称：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-9bcbb6f8e0315fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改表情包名称"></p><h1 id="四-测试"><a href="#四-测试" class="headerlink" title="四.测试"></a>四.测试</h1><p>完成上面这些步骤后，就可以编译然后进行测试了，模拟器中运行效果如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1018190-248481f796531dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终运行效果"></p><h1 id="五-提交审核"><a href="#五-提交审核" class="headerlink" title="五.提交审核"></a>五.提交审核</h1><p>（这一步不算在 10 分钟里哦，不属于开发过程唉，顺带提一下凑字数，🙄，购买开发者账号要等好几天呢）<br>若已经准备好了 iOS 开发者账号，就可以直接提交审核了，嗯，这个时候需要准备两张运行效果的屏幕截图，分别是 iPhone 和 iPad 的。</p><table><thead><tr><th style="text-align:center">Device</th><th style="text-align:center">Size</th></tr></thead><tbody><tr><td style="text-align:center">iPhone</td><td style="text-align:center">1242 x 2208</td></tr><tr><td style="text-align:center">iPad</td><td style="text-align:center">2048 x 2732</td></tr></tbody></table><p>然后应用图标使用之前准备好的 1024 x 1024 的应用图标即可，接下来填写好应用的各种信息，然后存储-提交审核即可。</p><p>本文 App 已经通过审核，iOS 10 以上系统的同学可以下载体验：<br><a href="https://itunes.apple.com/cn/app/yang-cong-hou-biao-qing-bao/id1166254758?mt=8" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/yang-cong-hou-biao-qing-bao/id1166254758?mt=8</a></p><p>同时预祝各位同学顺利开发出属于自己的表情包应用。</p><hr><p>本文链接：<a href="http://www.eyrefree.org/2016/11/24/2016-11-24-Coding-Emoji/">http://www.eyrefree.org/2016/11/24/2016-11-24-Coding-Emoji/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最近更新的 iOS 10 系统中，苹果开放了 iMessage Stickers 的开发，通俗的说法就是我们现在可以为 iMessage 开发表情包了。&lt;br&gt;表情包的开发十分简单，不需要写一行代码，只需要准备好图片资源即可。本文主要以 Coding 的&lt;a href=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="Sticker" scheme="http://www.eyrefree.org/tags/Sticker/"/>
    
  </entry>
  
  <entry>
    <title>iOS 为 App 添加 3D Touch 快捷菜单</title>
    <link href="http://www.eyrefree.org/3DTouch/"/>
    <id>http://www.eyrefree.org/3DTouch/</id>
    <published>2016-09-22T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.983Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 为 App 图标添加 3D Touch 快捷启动菜单，Demo 地址：<br><a href="https://github.com/EyreFree/EF3DTouchDemo" target="_blank" rel="noopener">https://github.com/EyreFree/EF3DTouchDemo</a></p><hr><h1 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1.注意事项"></a>1.注意事项</h1><p>3D Touch 只在 iOS 9 及以上版本得到支持，之前版本的 iOS 并不支持该功能；<br>3D Touch 只在 iPhone 6s 及以后型号的 iPhone 或 iPad Pro 上可用，更早的设备并不支持该功能。<br>具体可通过如下代码进行判断：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if self.traitCollection.forceTouchCapability == UIForceTouchCapability.available &#123;</span><br><span class="line">    print(&quot;支持 3D Touch&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;不支持 3D Touch&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-添加按钮"><a href="#2-添加按钮" class="headerlink" title="2.添加按钮"></a>2.添加按钮</h1><p>右键点击工程中的 Info.plist 文件选择打开方式为 Source Code：</p><center><br><img src="/images/3D-Touch-1.png" alt="以 Source Code 方式打开 Info.plist"><br></center><p>在其中填写如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIApplicationShortcutItems&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UIApplicationShortcutIconTypeShuffle&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;3D Touch 测试按钮&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;0&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;UIApplicationShortcutIconTypeLove&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;出来吧，小火龙！&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;1&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure><p>其中 UIApplicationShortcutItemIconType 项代表按钮图标，更多图标可以参见： <a href="https://developer.xamarin.com/api/type/UIKit.UIApplicationShortcutIconType/" target="_blank" rel="noopener">https://developer.xamarin.com/api/type/UIKit.UIApplicationShortcutIconType/</a></p><center><br><img src="/images/3D-Touch-2.png" alt="在 Info.plist 添加按钮代码"><br></center><p>这段代码添加了两个 3D Touch 按钮，“3D Touch 测试按钮”和“3D 出来吧，小火龙！”。</p><center><br><img src="/images/3D-Touch-3.png" alt="成功添加 3D Touch 按钮"><br></center><h1 id="3-添加功能代码"><a href="#3-添加功能代码" class="headerlink" title="3.添加功能代码"></a>3.添加功能代码</h1><p>打开 AppDelegate.swift 在其中添加如下代码，这段代码对点击按钮操作进行了处理，点击按钮后会进入 App 弹出一个显示按钮名称的对话框：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">    var sourceButtonTitle: String?</span><br><span class="line"></span><br><span class="line">    //根据按钮标题进行进一步操作</span><br><span class="line">    switch shortcutItem.localizedTitle &#123;</span><br><span class="line">    case &quot;3D Touch 测试按钮&quot;:</span><br><span class="line">        sourceButtonTitle = &quot;来源按钮：3D Touch 测试按钮&quot;</span><br><span class="line">        break</span><br><span class="line">    case &quot;出来吧，小火龙！&quot;:</span><br><span class="line">        sourceButtonTitle = &quot;来源按钮：出来吧，小火龙！&quot;</span><br><span class="line">        break</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //测试操作：弹出一个对话框显示来源按钮</span><br><span class="line">    if let trySourceButtonTitle = sourceButtonTitle &#123;</span><br><span class="line">        let alert = UIAlertController(title: nil, message: trySourceButtonTitle, preferredStyle: .alert)</span><br><span class="line">        alert.addAction(UIAlertAction(title: &quot;知道啦&quot;, style: .cancel, handler: nil))</span><br><span class="line">        self.window?.rootViewController?.present(alert, animated: true, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="/images/3D-Touch-4.png" alt="在 AppDelegate.swift 添加功能代码"><br></center><p>我们可以在这里添加代码从而实现根据不同来源按钮而执行不同的操作，结果如图所示：</p><center><br><img src="/images/3D-Touch-5.png" alt="操作结果"><br></center><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h1><p>1.需要注意的是，快捷启动按钮最多只能添加 4 个。<br>2.最新的 iOS 10 系统会给所有的 App 额外添加一个 3D Touch 分享按钮，点击后不打开 App 而是调用系统分享该应用的 App Store 下载地址。</p><hr><p>参考资料：</p><p><a href="http://iostuts.io/2015/10/08/how-to-add-quick-actions/" target="_blank" rel="noopener">http://iostuts.io/2015/10/08/how-to-add-quick-actions/</a><br><a href="http://stackoverflow.com/questions/36369058/how-to-check-3d-touch-available-in-iphone-programatically" target="_blank" rel="noopener">http://stackoverflow.com/questions/36369058/how-to-check-3d-touch-available-in-iphone-programatically</a></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2016/09/22/2016-09-22-3D-Touch/">http://www.eyrefree.org/2016/09/22/2016-09-22-3D-Touch/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS 为 App 图标添加 3D Touch 快捷启动菜单，Demo 地址：&lt;br&gt;&lt;a href=&quot;https://github.com/EyreFree/EF3DTouchDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.eyrefree.org/categories/iOS/"/>
    
    
      <category term="3D Touch" scheme="http://www.eyrefree.org/tags/3D-Touch/"/>
    
  </entry>
  
  <entry>
    <title>OS X 下统计项目代码行数</title>
    <link href="http://www.eyrefree.org/WrapCount/"/>
    <id>http://www.eyrefree.org/WrapCount/</id>
    <published>2016-07-19T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.983Z</updated>
    
    <content type="html"><![CDATA[<p>这是一条普通的计算代码行数的命令，在终端中切换到源码文件所在目录下执行即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.swift&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print | xargs wc -l</span><br></pre></td></tr></table></figure><p>可以计算代码行数，源码文件类型在命令里哦，可以根据自己需要修改，上面这条是计算 iOS 项目的，效果如下：</p><p><img src="/images/Wrap-Count-1.png" alt="Wrap-Count-1.png"></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2016/07/19/2016-07-19-Wrap-Count/">http://www.eyrefree.org/2016/07/19/2016-07-19-Wrap-Count/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一条普通的计算代码行数的命令，在终端中切换到源码文件所在目录下执行即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;find . &amp;qu
      
    
    </summary>
    
      <category term="OS X" scheme="http://www.eyrefree.org/categories/OS-X/"/>
    
    
      <category term="Nothing" scheme="http://www.eyrefree.org/tags/Nothing/"/>
    
  </entry>
  
  <entry>
    <title>Momentum：一个赏心悦目的应用</title>
    <link href="http://www.eyrefree.org/Momentum/"/>
    <id>http://www.eyrefree.org/Momentum/</id>
    <published>2016-06-02T07:00:00.000Z</published>
    <updated>2018-01-21T16:01:16.983Z</updated>
    
    <content type="html"><![CDATA[<p>Momentum，一个赏心悦目的 Chrome 应用，主要用来替换 Chrome 原有的 New Tab 页面，每天会更新风景图片，图片主要来自<a href="https://500px.com/" target="_blank" rel="noopener">500px</a>，来源和描述会显示在左下角，如图所示：</p><p><img src="/images/Momentum-Introduction-1.png" alt="Momentum-Introduction-1.png"></p><p>为我们增加了备忘、常用链接等实用的小工具（当然我只是为了看图…😂），在 Chrome应用商店的描述如下：</p><p><img src="/images/Momentum-Introduction-2.png" alt="Momentum-Introduction-2.png"></p><p>反正我觉得挺好用（看）的，😂，安利下，下载地址：<a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/momentum/</a></p><hr><p>本文链接：<a href="http://www.eyrefree.org/2016/06/02/2016-06-02-Momentum-Introduction/">http://www.eyrefree.org/2016/06/02/2016-06-02-Momentum-Introduction/</a></p><p>如文中无特殊说明，本站均使用以下协议保护：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">署名-非商业性使用-禁止演绎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Momentum，一个赏心悦目的 Chrome 应用，主要用来替换 Chrome 原有的 New Tab 页面，每天会更新风景图片，图片主要来自&lt;a href=&quot;https://500px.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;500px
      
    
    </summary>
    
      <category term="Tool" scheme="http://www.eyrefree.org/categories/Tool/"/>
    
    
      <category term="Chrome" scheme="http://www.eyrefree.org/tags/Chrome/"/>
    
  </entry>
  
</feed>
